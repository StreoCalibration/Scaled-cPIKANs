# 2ë‹¨ê³„: ë°ì´í„° ì¤€ë¹„ ğŸŸ¢

> **ë‚œì´ë„:** ì´ˆê¸‰  
> **ì†Œìš” ì‹œê°„:** 20ë¶„  
> **ì‚¬ì „ ì§€ì‹:** Python ê¸°ì´ˆ, NumPy ê¸°ë³¸ (ê¶Œì¥)

---

## ğŸ¯ í•™ìŠµ ëª©í‘œ

ì´ ë‹¨ê³„ë¥¼ ë§ˆì¹˜ë©´ ë‹¤ìŒì„ í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤:

- âœ… PINNì—ì„œ ë°ì´í„°ì˜ ì—­í•  ì´í•´í•˜ê¸°
- âœ… Latin Hypercube Sampling (LHS) ì‚¬ìš©í•˜ê¸°
- âœ… ì½œë¡œì¼€ì´ì…˜ í¬ì¸íŠ¸ ìƒì„±í•˜ê¸°
- âœ… ê²½ê³„ ì¡°ê±´ê³¼ ì´ˆê¸° ì¡°ê±´ ë°ì´í„° ì¤€ë¹„í•˜ê¸°
- âœ… í•©ì„± ë°ì´í„°ì™€ ì‹¤ì œ ë°ì´í„°ì˜ ì°¨ì´ ì´í•´í•˜ê¸°

---

## ğŸ¤” ì™œ ë°ì´í„°ê°€ í•„ìš”í•œê°€ìš”?

### PINNì˜ ë…íŠ¹í•œ ì 

ì¼ë°˜ì ì¸ ë”¥ëŸ¬ë‹ê³¼ ë‹¬ë¦¬, PINNì€ **ë°©ì •ì‹ ìì²´ë¥¼ í•™ìŠµ**í•©ë‹ˆë‹¤!

```
ì¼ë°˜ ë”¥ëŸ¬ë‹:  ì…ë ¥ â†’ ëª¨ë¸ â†’ ì¶œë ¥ (ì •ë‹µ í•„ìš”)
PINN:        ì…ë ¥ â†’ ëª¨ë¸ â†’ ì¶œë ¥ â†’ ë°©ì •ì‹ ê²€ì‚¬ (ì •ë‹µ ë¶ˆí•„ìš”!)
```

### ë°ì´í„°ì˜ ì—­í• 

PINNì—ì„œ ë°ì´í„°ëŠ” ë‘ ê°€ì§€ ìš©ë„ë¡œ ì‚¬ìš©ë©ë‹ˆë‹¤:

1. **ì½œë¡œì¼€ì´ì…˜ í¬ì¸íŠ¸ (Collocation Points)**  
   â†’ ë°©ì •ì‹ì„ ë§Œì¡±í•˜ëŠ”ì§€ í™•ì¸í•  ìœ„ì¹˜ë“¤

2. **ê²½ê³„/ì´ˆê¸° ì¡°ê±´ ë°ì´í„°**  
   â†’ ë¬¸ì œì˜ ê²½ê³„ ì¡°ê±´ì„ ê°€ë¥´ì³ì£¼ëŠ” ë°ì´í„°

---

## ğŸ“ ì½œë¡œì¼€ì´ì…˜ í¬ì¸íŠ¸ë€?

### ê°œë… ì´í•´í•˜ê¸°

ë¬¸ì œë¥¼ í’€ê³  ì‹¶ì€ ì˜ì—­(ë„ë©”ì¸)ì—ì„œ **ìƒ˜í”Œ í¬ì¸íŠ¸**ë¥¼ ì„ íƒí•˜ëŠ” ê²ƒì…ë‹ˆë‹¤.

**ì˜ˆì‹œ: 1D ë¬¸ì œ (0 â‰¤ x â‰¤ 1)**
```
ë„ë©”ì¸: â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
        0                 1
        
ì½œë¡œì¼€ì´ì…˜: â—   â—     â—  â—    â—
           xâ‚  xâ‚‚    xâ‚ƒ xâ‚„   xâ‚…
```

ê° ì ì—ì„œ ë°©ì •ì‹ì´ ì–¼ë§ˆë‚˜ ì˜ ë§Œì¡±ë˜ëŠ”ì§€ í™•ì¸í•©ë‹ˆë‹¤!

**ì˜ˆì‹œ: 2D ë¬¸ì œ (0 â‰¤ x, y â‰¤ 1)**
```
1 â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
  â”‚  â—    â—  â—  â”‚
  â”‚    â—      â— â”‚
  â”‚  â—  â—    â—  â”‚
0 â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
  0             1
```

---

## ğŸ² Latin Hypercube Sampling (LHS)

### ì™œ LHSë¥¼ ì‚¬ìš©í•˜ë‚˜ìš”?

ë¬´ì‘ìœ„ ìƒ˜í”Œë§ë³´ë‹¤ **ê³µê°„ì„ ë” ê· ì¼í•˜ê²Œ ì»¤ë²„**í•©ë‹ˆë‹¤!

**ë¬´ì‘ìœ„ ìƒ˜í”Œë§ (Random):**
```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ â—â—â—         â”‚  â† í•œìª½ì— ëª°ë¦¼
â”‚             â”‚
â”‚         â—â—â— â”‚  â† ë‹¤ë¥¸ ìª½ì— ëª°ë¦¼
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

**Latin Hypercube Sampling:**
```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  â—   â—   â—  â”‚  â† ê· ì¼í•œ ë¶„í¬
â”‚   â—  â—  â—   â”‚
â”‚  â—   â—   â—  â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

### LHS ì‚¬ìš© ì˜ˆì œ

#### 1D ë¬¸ì œ

```python
from src.data import LatinHypercubeSampler
import torch

# ìƒ˜í”ŒëŸ¬ ìƒì„±
sampler = LatinHypercubeSampler(
    n_points=100,              # ìƒì„±í•  í¬ì¸íŠ¸ ê°œìˆ˜
    domain_min=torch.tensor([0.0]),   # ë„ë©”ì¸ ìµœì†Ÿê°’
    domain_max=torch.tensor([1.0])    # ë„ë©”ì¸ ìµœëŒ“ê°’
)

# ìƒ˜í”Œ ìƒì„±
x_collocation = sampler.sample()  # shape: (100, 1)

print(f"ìƒ˜í”Œ shape: {x_collocation.shape}")
print(f"ìµœì†Ÿê°’: {x_collocation.min():.4f}")
print(f"ìµœëŒ“ê°’: {x_collocation.max():.4f}")
```

**ì¶œë ¥:**
```
ìƒ˜í”Œ shape: torch.Size([100, 1])
ìµœì†Ÿê°’: 0.0012
ìµœëŒ“ê°’: 0.9987
```

#### 2D ë¬¸ì œ

```python
# 2D ìƒ˜í”ŒëŸ¬ ìƒì„±
sampler_2d = LatinHypercubeSampler(
    n_points=500,
    domain_min=torch.tensor([0.0, 0.0]),   # (x_min, y_min)
    domain_max=torch.tensor([1.0, 1.0])    # (x_max, y_max)
)

# ìƒ˜í”Œ ìƒì„±
xy_collocation = sampler_2d.sample()  # shape: (500, 2)

# x, y ì¢Œí‘œ ë¶„ë¦¬
x = xy_collocation[:, 0]
y = xy_collocation[:, 1]

print(f"X ë²”ìœ„: [{x.min():.4f}, {x.max():.4f}]")
print(f"Y ë²”ìœ„: [{y.min():.4f}, {y.max():.4f}]")
```

### ì‹œê°í™”í•˜ê¸°

```python
import matplotlib.pyplot as plt

plt.figure(figsize=(8, 8))
plt.scatter(x.numpy(), y.numpy(), s=10, alpha=0.6)
plt.xlabel('x')
plt.ylabel('y')
plt.title('Latin Hypercube Sampling (2D)')
plt.grid(True, alpha=0.3)
plt.axis('equal')
plt.show()
```

---

## ğŸ”² ê²½ê³„ ì¡°ê±´ ë°ì´í„°

### ë¬´ì—‡ì¸ê°€ìš”?

ë¬¸ì œì˜ **ê²½ê³„ì—ì„œ** ê°’ì´ë‚˜ ë¯¸ë¶„ì´ ì£¼ì–´ì§„ ì¡°ê±´ì…ë‹ˆë‹¤.

**ì˜ˆì‹œ: 2D ì‚¬ê°í˜• ë„ë©”ì¸**
```
      y=1 (ìƒë‹¨ ê²½ê³„)
      â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
      â”‚           â”‚
x=0   â”‚  ë„ë©”ì¸   â”‚  x=1
(ì¢Œì¸¡) â”‚           â”‚  (ìš°ì¸¡)
      â”‚           â”‚
      â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
      y=0 (í•˜ë‹¨ ê²½ê³„)
```

### ê²½ê³„ ì¡°ê±´ ìœ í˜•

#### 1. Dirichlet ê²½ê³„ ì¡°ê±´ (ê°’ ê³ ì •)

> "ê²½ê³„ì—ì„œ uì˜ ê°’ì´ ì£¼ì–´ì§"

**ì˜ˆì‹œ:** ì˜¨ë„ê°€ 0Â°Cë¡œ ê³ ì •ëœ ë²½

```python
# í•˜ë‹¨ ê²½ê³„ (y=0)ì—ì„œ u=0
x_boundary = torch.linspace(0, 1, 50)  # x ì¢Œí‘œ
y_boundary = torch.zeros(50)           # y=0 (í•˜ë‹¨)
u_boundary = torch.zeros(50)           # u=0

# ê²½ê³„ ë°ì´í„° ìƒì„±
boundary_data = torch.stack([x_boundary, y_boundary], dim=1)
```

#### 2. Neumann ê²½ê³„ ì¡°ê±´ (ë¯¸ë¶„ ê³ ì •)

> "ê²½ê³„ì—ì„œ uì˜ ë¯¸ë¶„ì´ ì£¼ì–´ì§"

**ì˜ˆì‹œ:** ì—´ ìœ ì†ì´ 0 (ë‹¨ì—´ ë²½)

```python
# Neumann ì¡°ê±´: âˆ‚u/âˆ‚n = 0
# (PINN ì†ì‹¤ í•¨ìˆ˜ì—ì„œ ì²˜ë¦¬)
```

### ì „ì²´ ê²½ê³„ ë°ì´í„° ìƒì„± ì˜ˆì œ

```python
def create_boundary_data(n_boundary=50):
    """2D ì‚¬ê°í˜• ë„ë©”ì¸ì˜ ê²½ê³„ ë°ì´í„° ìƒì„±"""
    
    # í•˜ë‹¨ ê²½ê³„ (y=0)
    x_bottom = torch.linspace(0, 1, n_boundary)
    y_bottom = torch.zeros(n_boundary)
    
    # ìƒë‹¨ ê²½ê³„ (y=1)
    x_top = torch.linspace(0, 1, n_boundary)
    y_top = torch.ones(n_boundary)
    
    # ì¢Œì¸¡ ê²½ê³„ (x=0)
    x_left = torch.zeros(n_boundary)
    y_left = torch.linspace(0, 1, n_boundary)
    
    # ìš°ì¸¡ ê²½ê³„ (x=1)
    x_right = torch.ones(n_boundary)
    y_right = torch.linspace(0, 1, n_boundary)
    
    # ëª¨ë“  ê²½ê³„ í•©ì¹˜ê¸°
    x_bc = torch.cat([x_bottom, x_top, x_left, x_right])
    y_bc = torch.cat([y_bottom, y_top, y_left, y_right])
    boundary_points = torch.stack([x_bc, y_bc], dim=1)  # (200, 2)
    
    # ê²½ê³„ ê°’ (ì˜ˆ: ëª¨ë‘ 0)
    boundary_values = torch.zeros(200, 1)
    
    return boundary_points, boundary_values

# ì‚¬ìš© ì˜ˆì œ
bc_points, bc_values = create_boundary_data()
print(f"ê²½ê³„ í¬ì¸íŠ¸ ê°œìˆ˜: {bc_points.shape[0]}")
```

---

## â° ì´ˆê¸° ì¡°ê±´ ë°ì´í„° (ì‹œê°„ ì˜ì¡´ ë¬¸ì œ)

### ë¬´ì—‡ì¸ê°€ìš”?

**ì‹œê°„ì— ë”°ë¼ ë³€í•˜ëŠ” ë¬¸ì œ**ì—ì„œ t=0ì¼ ë•Œì˜ ì´ˆê¸° ìƒíƒœì…ë‹ˆë‹¤.

**ì˜ˆì‹œ:** ì—´ ì „ë‹¬ ë¬¸ì œ

```
t=0 ì‹œì ì˜ ì˜¨ë„ ë¶„í¬ë¥¼ ì•Œë ¤ì¤Œ
```

### ì´ˆê¸° ì¡°ê±´ ìƒì„± ì˜ˆì œ

```python
def create_initial_condition(n_initial=100):
    """ì´ˆê¸° ì¡°ê±´ ë°ì´í„° ìƒì„± (t=0)"""
    
    # ê³µê°„ ì¢Œí‘œ ìƒ˜í”Œë§
    x_ic = torch.linspace(0, 1, n_initial)
    t_ic = torch.zeros(n_initial)  # t=0
    
    # ì´ˆê¸° ì˜¨ë„ (ì˜ˆ: ì‚¬ì¸ í•¨ìˆ˜)
    u_ic = torch.sin(torch.pi * x_ic)
    
    # ë°ì´í„° í˜•ì‹í™”
    initial_points = torch.stack([x_ic, t_ic], dim=1)  # (100, 2)
    initial_values = u_ic.unsqueeze(1)                  # (100, 1)
    
    return initial_points, initial_values

# ì‚¬ìš© ì˜ˆì œ
ic_points, ic_values = create_initial_condition()
print(f"ì´ˆê¸° ì¡°ê±´ í¬ì¸íŠ¸: {ic_points.shape}")
print(f"ì´ˆê¸° ê°’ ë²”ìœ„: [{ic_values.min():.4f}, {ic_values.max():.4f}]")
```

---

## ğŸ”„ ë°ì´í„° ì¤€ë¹„ ì „ì²´ ì›Œí¬í”Œë¡œìš°

### ì „í˜•ì ì¸ PINN ë¬¸ì œ ì„¤ì •

```python
import torch
from src.data import LatinHypercubeSampler

def prepare_pinn_data():
    """PINN í›ˆë ¨ ë°ì´í„° ì „ì²´ ì¤€ë¹„"""
    
    # 1. ì½œë¡œì¼€ì´ì…˜ í¬ì¸íŠ¸ (ë„ë©”ì¸ ë‚´ë¶€)
    sampler = LatinHypercubeSampler(
        n_points=1000,
        domain_min=torch.tensor([0.0, 0.0]),
        domain_max=torch.tensor([1.0, 1.0])
    )
    collocation_points = sampler.sample()
    
    # 2. ê²½ê³„ ì¡°ê±´
    bc_points, bc_values = create_boundary_data(n_boundary=100)
    
    # 3. ì´ˆê¸° ì¡°ê±´ (ì‹œê°„ ì˜ì¡´ ë¬¸ì œì¸ ê²½ìš°)
    ic_points, ic_values = create_initial_condition(n_initial=100)
    
    return {
        'collocation': collocation_points,
        'boundary': (bc_points, bc_values),
        'initial': (ic_points, ic_values)
    }

# ì‹¤í–‰
data = prepare_pinn_data()
print(f"ì½œë¡œì¼€ì´ì…˜: {data['collocation'].shape}")
print(f"ê²½ê³„ ì¡°ê±´: {data['boundary'][0].shape}")
print(f"ì´ˆê¸° ì¡°ê±´: {data['initial'][0].shape}")
```

**ì¶œë ¥:**
```
ì½œë¡œì¼€ì´ì…˜: torch.Size([1000, 2])
ê²½ê³„ ì¡°ê±´: torch.Size([200, 2])
ì´ˆê¸° ì¡°ê±´: torch.Size([100, 2])
```

---

## ğŸ¨ í•©ì„± ë°ì´í„° vs ì‹¤ì œ ë°ì´í„°

### í•©ì„± ë°ì´í„°

**íŠ¹ì§•:**
- í”„ë¡œê·¸ë¨ìœ¼ë¡œ ìƒì„±
- ì •í™•í•œ ì •ë‹µì„ ì•Œ ìˆ˜ ìˆìŒ
- ë””ë²„ê¹…ê³¼ ê²€ì¦ì— ìœ ìš©

**ì˜ˆì‹œ:**
```python
# í•´ì„í•´ê°€ ì•Œë ¤ì§„ ë¬¸ì œ
# u(x, y) = sin(Ï€x) * sin(Ï€y)
x = torch.linspace(0, 1, 100)
y = torch.linspace(0, 1, 100)
u_exact = torch.sin(torch.pi * x) * torch.sin(torch.pi * y)
```

### ì‹¤ì œ ë°ì´í„°

**íŠ¹ì§•:**
- ì‹¤í—˜ì´ë‚˜ ì¸¡ì •ì—ì„œ íšë“
- ë…¸ì´ì¦ˆê°€ í¬í•¨ë  ìˆ˜ ìˆìŒ
- ì‹¤ì œ ë¬¸ì œ í•´ê²°ì— í•„ìš”

**ì˜ˆì‹œ:**
```python
# ì‹¤ì œ ì˜¨ë„ ì„¼ì„œ ë°ì´í„°
import numpy as np

# CSV íŒŒì¼ì—ì„œ ë¡œë“œ
data = np.loadtxt('temperature_data.csv', delimiter=',')
x_measured = torch.from_numpy(data[:, 0])
y_measured = torch.from_numpy(data[:, 1])
temperature_measured = torch.from_numpy(data[:, 2])
```

---

## ğŸ§ª ì‹¤ìŠµ: 1D Helmholtz ë°©ì •ì‹ ë°ì´í„° ì¤€ë¹„

### ë¬¸ì œ ì •ì˜

Helmholtz ë°©ì •ì‹ì„ í’€ì–´ë´…ì‹œë‹¤:
```
dÂ²u/dxÂ² + kÂ²u = f(x),  0 â‰¤ x â‰¤ 1
u(0) = 0, u(1) = 0  (ê²½ê³„ ì¡°ê±´)
```

### ë°ì´í„° ì¤€ë¹„ ì½”ë“œ

```python
import torch
from src.data import LatinHypercubeSampler
import matplotlib.pyplot as plt

# íŒŒë¼ë¯¸í„°
k = 1.0  # íŒŒìˆ˜
n_collocation = 100
n_boundary = 2  # 1Dì´ë¯€ë¡œ ê²½ê³„ëŠ” 2ê°œ (x=0, x=1)

# 1. ì½œë¡œì¼€ì´ì…˜ í¬ì¸íŠ¸
sampler = LatinHypercubeSampler(
    n_points=n_collocation,
    domain_min=torch.tensor([0.0]),
    domain_max=torch.tensor([1.0])
)
x_collocation = sampler.sample()

# 2. ê²½ê³„ ì¡°ê±´
x_bc = torch.tensor([[0.0], [1.0]])  # x=0, x=1
u_bc = torch.zeros(2, 1)             # u(0)=0, u(1)=0

# 3. ì†ŒìŠ¤ í•­ (right-hand side)
def f(x):
    """ì†ŒìŠ¤ í•­ í•¨ìˆ˜"""
    return -k**2 * torch.sin(torch.pi * x)

f_collocation = f(x_collocation)

# ì‹œê°í™”
plt.figure(figsize=(10, 4))

# ì½œë¡œì¼€ì´ì…˜ í¬ì¸íŠ¸
plt.subplot(1, 2, 1)
plt.scatter(x_collocation.numpy(), torch.zeros_like(x_collocation).numpy(), 
            s=20, alpha=0.6, label='Collocation')
plt.scatter(x_bc.numpy(), torch.zeros_like(x_bc).numpy(), 
            s=100, c='red', marker='x', label='Boundary')
plt.xlabel('x')
plt.title('ìƒ˜í”Œ í¬ì¸íŠ¸ ë¶„í¬')
plt.legend()
plt.grid(True, alpha=0.3)

# ì†ŒìŠ¤ í•­
plt.subplot(1, 2, 2)
x_plot = torch.linspace(0, 1, 200)
plt.plot(x_plot.numpy(), f(x_plot).numpy(), label='f(x)')
plt.scatter(x_collocation.numpy(), f_collocation.numpy(), 
            s=10, alpha=0.6, label='Sampled')
plt.xlabel('x')
plt.ylabel('f(x)')
plt.title('ì†ŒìŠ¤ í•­ í•¨ìˆ˜')
plt.legend()
plt.grid(True, alpha=0.3)

plt.tight_layout()
plt.show()

print(f"âœ… ë°ì´í„° ì¤€ë¹„ ì™„ë£Œ!")
print(f"   ì½œë¡œì¼€ì´ì…˜: {x_collocation.shape}")
print(f"   ê²½ê³„ ì¡°ê±´: {x_bc.shape}")
```

---

## ğŸ“Š ë°ì´í„° í’ˆì§ˆ ì²´í¬

### ì²´í¬ë¦¬ìŠ¤íŠ¸

ë°ì´í„°ë¥¼ ì¤€ë¹„í•œ í›„ ë‹¤ìŒì„ í™•ì¸í•˜ì„¸ìš”:

#### 1. ìƒ˜í”Œ ê°œìˆ˜

```python
print(f"ì½œë¡œì¼€ì´ì…˜ í¬ì¸íŠ¸: {collocation_points.shape[0]}ê°œ")
print(f"ê²½ê³„ í¬ì¸íŠ¸: {bc_points.shape[0]}ê°œ")
```

**ê¶Œì¥ ê°œìˆ˜:**
- 1D: 100~500
- 2D: 1000~5000
- 3D: 5000~20000

#### 2. ë„ë©”ì¸ ë²”ìœ„

```python
print(f"X ë²”ìœ„: [{collocation_points[:, 0].min():.4f}, {collocation_points[:, 0].max():.4f}]")
print(f"Y ë²”ìœ„: [{collocation_points[:, 1].min():.4f}, {collocation_points[:, 1].max():.4f}]")
```

ê²½ê³„ê°€ ë„ë©”ì¸ì„ ë²—ì–´ë‚˜ì§€ ì•ŠëŠ”ì§€ í™•ì¸!

#### 3. í…ì„œ í˜•íƒœ

```python
assert collocation_points.ndim == 2, "2D í…ì„œì—¬ì•¼ í•©ë‹ˆë‹¤"
assert collocation_points.shape[1] == 2, "ì¢Œí‘œ ì°¨ì›ì´ ë§ì•„ì•¼ í•©ë‹ˆë‹¤"
```

#### 4. NaN ì²´í¬

```python
assert not torch.isnan(collocation_points).any(), "NaN ê°’ì´ ìˆìŠµë‹ˆë‹¤!"
assert not torch.isinf(collocation_points).any(), "Inf ê°’ì´ ìˆìŠµë‹ˆë‹¤!"
```

---

## ğŸ¯ ì²´í¬í¬ì¸íŠ¸

ë‹¤ìŒ í•­ëª©ì„ ëª¨ë‘ ìˆ˜í–‰í–ˆìœ¼ë©´ ë‹¤ìŒ ë‹¨ê³„ë¡œ ì§„í–‰í•˜ì„¸ìš”!

- [ ] Latin Hypercube Sampling ê°œë… ì´í•´
- [ ] ì½œë¡œì¼€ì´ì…˜ í¬ì¸íŠ¸ ìƒì„± ì„±ê³µ
- [ ] ê²½ê³„ ì¡°ê±´ ë°ì´í„° ì¤€ë¹„
- [ ] ì´ˆê¸° ì¡°ê±´ ë°ì´í„° ì¤€ë¹„ (ì‹œê°„ ì˜ì¡´ ë¬¸ì œ)
- [ ] ë°ì´í„° ì‹œê°í™” í™•ì¸
- [ ] ë°ì´í„° í’ˆì§ˆ ì²´í¬ ì™„ë£Œ

---

## ğŸ†˜ ìì£¼ ë¬»ëŠ” ì§ˆë¬¸

### Q1: ì½œë¡œì¼€ì´ì…˜ í¬ì¸íŠ¸ëŠ” ëª‡ ê°œê°€ ì ë‹¹í•œê°€ìš”?

**A:** ë¬¸ì œì˜ ë³µì¡ë„ì— ë”°ë¼ ë‹¤ë¦…ë‹ˆë‹¤:
- ê°„ë‹¨í•œ 1D ë¬¸ì œ: 100~500ê°œ
- 2D ë¬¸ì œ: 1000~5000ê°œ
- ë³µì¡í•œ 3D ë¬¸ì œ: 10000ê°œ ì´ìƒ

"ë§ì„ìˆ˜ë¡ ì¢‹ì§€ë§Œ, í›ˆë ¨ ì‹œê°„ì´ ëŠ˜ì–´ë‚©ë‹ˆë‹¤."

### Q2: ê²½ê³„ í¬ì¸íŠ¸ëŠ” ê¼­ í•„ìš”í•œê°€ìš”?

**A:** ë„¤! ê²½ê³„ ì¡°ê±´ì´ ì—†ìœ¼ë©´ ë¬´í•œíˆ ë§ì€ í•´ê°€ ì¡´ì¬í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤.

### Q3: LHS ëŒ€ì‹  ëœë¤ ìƒ˜í”Œë§ì„ ì¨ë„ ë˜ë‚˜ìš”?

**A:** ê°€ëŠ¥í•˜ì§€ë§Œ, LHSê°€ ë” íš¨ìœ¨ì ì…ë‹ˆë‹¤. ê°™ì€ í¬ì¸íŠ¸ ê°œìˆ˜ë¡œ ë” ì¢‹ì€ ì»¤ë²„ë¦¬ì§€ë¥¼ ì–»ì„ ìˆ˜ ìˆìŠµë‹ˆë‹¤.

### Q4: ë°ì´í„°ì— ë…¸ì´ì¦ˆê°€ ìˆìœ¼ë©´ ì–´ë–»ê²Œ í•˜ë‚˜ìš”?

**A:** PINNì€ ë…¸ì´ì¦ˆì— ê°•ê±´í•©ë‹ˆë‹¤! ì†ì‹¤ í•¨ìˆ˜ì—ì„œ ìë™ìœ¼ë¡œ í•„í„°ë§ë©ë‹ˆë‹¤.

---

## ğŸ“š ì¶”ê°€ ìë£Œ

- **Latin Hypercube Sampling ë…¼ë¬¸:** McKay et al. (1979)
- **SciPy LHS ë¬¸ì„œ:** [https://docs.scipy.org/doc/scipy/reference/generated/scipy.stats.qmc.LatinHypercube.html](https://docs.scipy.org/doc/scipy/reference/generated/scipy.stats.qmc.LatinHypercube.html)

---

## ğŸ‰ ì¶•í•˜í•©ë‹ˆë‹¤!

ë°ì´í„° ì¤€ë¹„ë¥¼ ë§ˆìŠ¤í„°í–ˆìŠµë‹ˆë‹¤! ì´ì œ ëª¨ë¸ì„ ì •ì˜í•  ì¤€ë¹„ê°€ ë˜ì—ˆìŠµë‹ˆë‹¤.

**ë‹¤ìŒ ë‹¨ê³„:**

ğŸ‘‰ [3ë‹¨ê³„: ëª¨ë¸ ì •ì˜ë¡œ ì´ë™í•˜ê¸°](03_ëª¨ë¸ì •ì˜.md)

ë˜ëŠ” [ë©”ì¸ ê°€ì´ë“œë¡œ ëŒì•„ê°€ê¸°](../ì‚¬ìš©ì_ê°€ì´ë“œ.md)

---

*ë§ˆì§€ë§‰ ì—…ë°ì´íŠ¸: 2025ë…„ 1ì›”*
