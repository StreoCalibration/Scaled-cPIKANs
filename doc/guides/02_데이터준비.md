# 2단계: 데이터 준비 🟢

> **난이도:** 초급  
> **소요 시간:** 20분  
> **사전 지식:** Python 기초, NumPy 기본 (권장)

---

## 🎯 학습 목표

이 단계를 마치면 다음을 할 수 있습니다:

- ✅ PINN에서 데이터의 역할 이해하기
- ✅ Latin Hypercube Sampling (LHS) 사용하기
- ✅ 콜로케이션 포인트 생성하기
- ✅ 경계 조건과 초기 조건 데이터 준비하기
- ✅ 합성 데이터와 실제 데이터의 차이 이해하기

---

## 🤔 왜 데이터가 필요한가요?

### PINN의 독특한 점

일반적인 딥러닝과 달리, PINN은 **방정식 자체를 학습**합니다!

```
일반 딥러닝:  입력 → 모델 → 출력 (정답 필요)
PINN:        입력 → 모델 → 출력 → 방정식 검사 (정답 불필요!)
```

### 데이터의 역할

PINN에서 데이터는 두 가지 용도로 사용됩니다:

1. **콜로케이션 포인트 (Collocation Points)**  
   → 방정식을 만족하는지 확인할 위치들

2. **경계/초기 조건 데이터**  
   → 문제의 경계 조건을 가르쳐주는 데이터

---

## 📐 콜로케이션 포인트란?

### 개념 이해하기

문제를 풀고 싶은 영역(도메인)에서 **샘플 포인트**를 선택하는 것입니다.

**예시: 1D 문제 (0 ≤ x ≤ 1)**
```
도메인: ────────────────────
        0                 1
        
콜로케이션: ●   ●     ●  ●    ●
           x₁  x₂    x₃ x₄   x₅
```

각 점에서 방정식이 얼마나 잘 만족되는지 확인합니다!

**예시: 2D 문제 (0 ≤ x, y ≤ 1)**
```
1 ┌─────────────┐
  │  ●    ●  ●  │
  │    ●      ● │
  │  ●  ●    ●  │
0 └─────────────┘
  0             1
```

---

## 🎲 Latin Hypercube Sampling (LHS)

### 왜 LHS를 사용하나요?

무작위 샘플링보다 **공간을 더 균일하게 커버**합니다!

**무작위 샘플링 (Random):**
```
┌─────────────┐
│ ●●●         │  ← 한쪽에 몰림
│             │
│         ●●● │  ← 다른 쪽에 몰림
└─────────────┘
```

**Latin Hypercube Sampling:**
```
┌─────────────┐
│  ●   ●   ●  │  ← 균일한 분포
│   ●  ●  ●   │
│  ●   ●   ●  │
└─────────────┘
```

### LHS 사용 예제

#### 1D 문제

```python
from src.data import LatinHypercubeSampler
import torch

# 샘플러 생성
sampler = LatinHypercubeSampler(
    n_points=100,              # 생성할 포인트 개수
    domain_min=torch.tensor([0.0]),   # 도메인 최솟값
    domain_max=torch.tensor([1.0])    # 도메인 최댓값
)

# 샘플 생성
x_collocation = sampler.sample()  # shape: (100, 1)

print(f"샘플 shape: {x_collocation.shape}")
print(f"최솟값: {x_collocation.min():.4f}")
print(f"최댓값: {x_collocation.max():.4f}")
```

**출력:**
```
샘플 shape: torch.Size([100, 1])
최솟값: 0.0012
최댓값: 0.9987
```

#### 2D 문제

```python
# 2D 샘플러 생성
sampler_2d = LatinHypercubeSampler(
    n_points=500,
    domain_min=torch.tensor([0.0, 0.0]),   # (x_min, y_min)
    domain_max=torch.tensor([1.0, 1.0])    # (x_max, y_max)
)

# 샘플 생성
xy_collocation = sampler_2d.sample()  # shape: (500, 2)

# x, y 좌표 분리
x = xy_collocation[:, 0]
y = xy_collocation[:, 1]

print(f"X 범위: [{x.min():.4f}, {x.max():.4f}]")
print(f"Y 범위: [{y.min():.4f}, {y.max():.4f}]")
```

### 시각화하기

```python
import matplotlib.pyplot as plt

plt.figure(figsize=(8, 8))
plt.scatter(x.numpy(), y.numpy(), s=10, alpha=0.6)
plt.xlabel('x')
plt.ylabel('y')
plt.title('Latin Hypercube Sampling (2D)')
plt.grid(True, alpha=0.3)
plt.axis('equal')
plt.show()
```

---

## 🔲 경계 조건 데이터

### 무엇인가요?

문제의 **경계에서** 값이나 미분이 주어진 조건입니다.

**예시: 2D 사각형 도메인**
```
      y=1 (상단 경계)
      ─────────────
      │           │
x=0   │  도메인   │  x=1
(좌측) │           │  (우측)
      │           │
      ─────────────
      y=0 (하단 경계)
```

### 경계 조건 유형

#### 1. Dirichlet 경계 조건 (값 고정)

> "경계에서 u의 값이 주어짐"

**예시:** 온도가 0°C로 고정된 벽

```python
# 하단 경계 (y=0)에서 u=0
x_boundary = torch.linspace(0, 1, 50)  # x 좌표
y_boundary = torch.zeros(50)           # y=0 (하단)
u_boundary = torch.zeros(50)           # u=0

# 경계 데이터 생성
boundary_data = torch.stack([x_boundary, y_boundary], dim=1)
```

#### 2. Neumann 경계 조건 (미분 고정)

> "경계에서 u의 미분이 주어짐"

**예시:** 열 유속이 0 (단열 벽)

```python
# Neumann 조건: ∂u/∂n = 0
# (PINN 손실 함수에서 처리)
```

### 전체 경계 데이터 생성 예제

```python
def create_boundary_data(n_boundary=50):
    """2D 사각형 도메인의 경계 데이터 생성"""
    
    # 하단 경계 (y=0)
    x_bottom = torch.linspace(0, 1, n_boundary)
    y_bottom = torch.zeros(n_boundary)
    
    # 상단 경계 (y=1)
    x_top = torch.linspace(0, 1, n_boundary)
    y_top = torch.ones(n_boundary)
    
    # 좌측 경계 (x=0)
    x_left = torch.zeros(n_boundary)
    y_left = torch.linspace(0, 1, n_boundary)
    
    # 우측 경계 (x=1)
    x_right = torch.ones(n_boundary)
    y_right = torch.linspace(0, 1, n_boundary)
    
    # 모든 경계 합치기
    x_bc = torch.cat([x_bottom, x_top, x_left, x_right])
    y_bc = torch.cat([y_bottom, y_top, y_left, y_right])
    boundary_points = torch.stack([x_bc, y_bc], dim=1)  # (200, 2)
    
    # 경계 값 (예: 모두 0)
    boundary_values = torch.zeros(200, 1)
    
    return boundary_points, boundary_values

# 사용 예제
bc_points, bc_values = create_boundary_data()
print(f"경계 포인트 개수: {bc_points.shape[0]}")
```

---

## ⏰ 초기 조건 데이터 (시간 의존 문제)

### 무엇인가요?

**시간에 따라 변하는 문제**에서 t=0일 때의 초기 상태입니다.

**예시:** 열 전달 문제

```
t=0 시점의 온도 분포를 알려줌
```

### 초기 조건 생성 예제

```python
def create_initial_condition(n_initial=100):
    """초기 조건 데이터 생성 (t=0)"""
    
    # 공간 좌표 샘플링
    x_ic = torch.linspace(0, 1, n_initial)
    t_ic = torch.zeros(n_initial)  # t=0
    
    # 초기 온도 (예: 사인 함수)
    u_ic = torch.sin(torch.pi * x_ic)
    
    # 데이터 형식화
    initial_points = torch.stack([x_ic, t_ic], dim=1)  # (100, 2)
    initial_values = u_ic.unsqueeze(1)                  # (100, 1)
    
    return initial_points, initial_values

# 사용 예제
ic_points, ic_values = create_initial_condition()
print(f"초기 조건 포인트: {ic_points.shape}")
print(f"초기 값 범위: [{ic_values.min():.4f}, {ic_values.max():.4f}]")
```

---

## 🔄 데이터 준비 전체 워크플로우

### 전형적인 PINN 문제 설정

```python
import torch
from src.data import LatinHypercubeSampler

def prepare_pinn_data():
    """PINN 훈련 데이터 전체 준비"""
    
    # 1. 콜로케이션 포인트 (도메인 내부)
    sampler = LatinHypercubeSampler(
        n_points=1000,
        domain_min=torch.tensor([0.0, 0.0]),
        domain_max=torch.tensor([1.0, 1.0])
    )
    collocation_points = sampler.sample()
    
    # 2. 경계 조건
    bc_points, bc_values = create_boundary_data(n_boundary=100)
    
    # 3. 초기 조건 (시간 의존 문제인 경우)
    ic_points, ic_values = create_initial_condition(n_initial=100)
    
    return {
        'collocation': collocation_points,
        'boundary': (bc_points, bc_values),
        'initial': (ic_points, ic_values)
    }

# 실행
data = prepare_pinn_data()
print(f"콜로케이션: {data['collocation'].shape}")
print(f"경계 조건: {data['boundary'][0].shape}")
print(f"초기 조건: {data['initial'][0].shape}")
```

**출력:**
```
콜로케이션: torch.Size([1000, 2])
경계 조건: torch.Size([200, 2])
초기 조건: torch.Size([100, 2])
```

---

## 🎨 합성 데이터 vs 실제 데이터

### 합성 데이터

**특징:**
- 프로그램으로 생성
- 정확한 정답을 알 수 있음
- 디버깅과 검증에 유용

**예시:**
```python
# 해석해가 알려진 문제
# u(x, y) = sin(πx) * sin(πy)
x = torch.linspace(0, 1, 100)
y = torch.linspace(0, 1, 100)
u_exact = torch.sin(torch.pi * x) * torch.sin(torch.pi * y)
```

### 실제 데이터

**특징:**
- 실험이나 측정에서 획득
- 노이즈가 포함될 수 있음
- 실제 문제 해결에 필요

**예시:**
```python
# 실제 온도 센서 데이터
import numpy as np

# CSV 파일에서 로드
data = np.loadtxt('temperature_data.csv', delimiter=',')
x_measured = torch.from_numpy(data[:, 0])
y_measured = torch.from_numpy(data[:, 1])
temperature_measured = torch.from_numpy(data[:, 2])
```

---

## 🧪 실습: 1D Helmholtz 방정식 데이터 준비

### 문제 정의

Helmholtz 방정식을 풀어봅시다:
```
d²u/dx² + k²u = f(x),  0 ≤ x ≤ 1
u(0) = 0, u(1) = 0  (경계 조건)
```

### 데이터 준비 코드

```python
import torch
from src.data import LatinHypercubeSampler
import matplotlib.pyplot as plt

# 파라미터
k = 1.0  # 파수
n_collocation = 100
n_boundary = 2  # 1D이므로 경계는 2개 (x=0, x=1)

# 1. 콜로케이션 포인트
sampler = LatinHypercubeSampler(
    n_points=n_collocation,
    domain_min=torch.tensor([0.0]),
    domain_max=torch.tensor([1.0])
)
x_collocation = sampler.sample()

# 2. 경계 조건
x_bc = torch.tensor([[0.0], [1.0]])  # x=0, x=1
u_bc = torch.zeros(2, 1)             # u(0)=0, u(1)=0

# 3. 소스 항 (right-hand side)
def f(x):
    """소스 항 함수"""
    return -k**2 * torch.sin(torch.pi * x)

f_collocation = f(x_collocation)

# 시각화
plt.figure(figsize=(10, 4))

# 콜로케이션 포인트
plt.subplot(1, 2, 1)
plt.scatter(x_collocation.numpy(), torch.zeros_like(x_collocation).numpy(), 
            s=20, alpha=0.6, label='Collocation')
plt.scatter(x_bc.numpy(), torch.zeros_like(x_bc).numpy(), 
            s=100, c='red', marker='x', label='Boundary')
plt.xlabel('x')
plt.title('샘플 포인트 분포')
plt.legend()
plt.grid(True, alpha=0.3)

# 소스 항
plt.subplot(1, 2, 2)
x_plot = torch.linspace(0, 1, 200)
plt.plot(x_plot.numpy(), f(x_plot).numpy(), label='f(x)')
plt.scatter(x_collocation.numpy(), f_collocation.numpy(), 
            s=10, alpha=0.6, label='Sampled')
plt.xlabel('x')
plt.ylabel('f(x)')
plt.title('소스 항 함수')
plt.legend()
plt.grid(True, alpha=0.3)

plt.tight_layout()
plt.show()

print(f"✅ 데이터 준비 완료!")
print(f"   콜로케이션: {x_collocation.shape}")
print(f"   경계 조건: {x_bc.shape}")
```

---

## 📊 데이터 품질 체크

### 체크리스트

데이터를 준비한 후 다음을 확인하세요:

#### 1. 샘플 개수

```python
print(f"콜로케이션 포인트: {collocation_points.shape[0]}개")
print(f"경계 포인트: {bc_points.shape[0]}개")
```

**권장 개수:**
- 1D: 100~500
- 2D: 1000~5000
- 3D: 5000~20000

#### 2. 도메인 범위

```python
print(f"X 범위: [{collocation_points[:, 0].min():.4f}, {collocation_points[:, 0].max():.4f}]")
print(f"Y 범위: [{collocation_points[:, 1].min():.4f}, {collocation_points[:, 1].max():.4f}]")
```

경계가 도메인을 벗어나지 않는지 확인!

#### 3. 텐서 형태

```python
assert collocation_points.ndim == 2, "2D 텐서여야 합니다"
assert collocation_points.shape[1] == 2, "좌표 차원이 맞아야 합니다"
```

#### 4. NaN 체크

```python
assert not torch.isnan(collocation_points).any(), "NaN 값이 있습니다!"
assert not torch.isinf(collocation_points).any(), "Inf 값이 있습니다!"
```

---

## 🎯 체크포인트

다음 항목을 모두 수행했으면 다음 단계로 진행하세요!

- [ ] Latin Hypercube Sampling 개념 이해
- [ ] 콜로케이션 포인트 생성 성공
- [ ] 경계 조건 데이터 준비
- [ ] 초기 조건 데이터 준비 (시간 의존 문제)
- [ ] 데이터 시각화 확인
- [ ] 데이터 품질 체크 완료

---

## 🆘 자주 묻는 질문

### Q1: 콜로케이션 포인트는 몇 개가 적당한가요?

**A:** 문제의 복잡도에 따라 다릅니다:
- 간단한 1D 문제: 100~500개
- 2D 문제: 1000~5000개
- 복잡한 3D 문제: 10000개 이상

"많을수록 좋지만, 훈련 시간이 늘어납니다."

### Q2: 경계 포인트는 꼭 필요한가요?

**A:** 네! 경계 조건이 없으면 무한히 많은 해가 존재할 수 있습니다.

### Q3: LHS 대신 랜덤 샘플링을 써도 되나요?

**A:** 가능하지만, LHS가 더 효율적입니다. 같은 포인트 개수로 더 좋은 커버리지를 얻을 수 있습니다.

### Q4: 데이터에 노이즈가 있으면 어떻게 하나요?

**A:** PINN은 노이즈에 강건합니다! 손실 함수에서 자동으로 필터링됩니다.

---

## 📚 추가 자료

- **Latin Hypercube Sampling 논문:** McKay et al. (1979)
- **SciPy LHS 문서:** [https://docs.scipy.org/doc/scipy/reference/generated/scipy.stats.qmc.LatinHypercube.html](https://docs.scipy.org/doc/scipy/reference/generated/scipy.stats.qmc.LatinHypercube.html)

---

## 🎉 축하합니다!

데이터 준비를 마스터했습니다! 이제 모델을 정의할 준비가 되었습니다.

**다음 단계:**

👉 [3단계: 모델 정의로 이동하기](03_모델정의.md)

또는 [메인 가이드로 돌아가기](../사용자_가이드.md)

---

*마지막 업데이트: 2025년 1월*
