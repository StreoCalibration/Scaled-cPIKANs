# 6단계: 결과 분석 🟢

> **난이도:** 초급  
> **소요 시간:** 30분  
> **사전 지식:** 기본적인 통계 및 시각화

---

## 🎯 학습 목표

이 단계를 마치면 다음을 할 수 있습니다:

- ✅ 훈련된 모델에서 예측값 추출하기
- ✅ 다양한 오차 메트릭 계산하기
- ✅ 1D/2D/3D 결과 시각화하기
- ✅ 점별 잔차 분석하기
- ✅ 모델 성능 평가 및 해석하기

---

## 📊 결과 추출

### 기본 예측

```python
import torch
from src.models import Scaled_cPIKAN

# 훈련된 모델 (이미 학습 완료)
model.eval()  # 평가 모드

# 테스트 포인트 생성
x_test = torch.linspace(0, 1, 200).unsqueeze(1)

# 예측 (그래디언트 불필요)
with torch.no_grad():
    u_pred = model(x_test)

print(f"예측 shape: {u_pred.shape}")
print(f"예측 범위: [{u_pred.min():.4f}, {u_pred.max():.4f}]")
```

### GPU에서 예측

```python
# GPU 모델인 경우
device = next(model.parameters()).device
x_test = x_test.to(device)

with torch.no_grad():
    u_pred = model(x_test)
    u_pred = u_pred.cpu()  # CPU로 이동 (시각화용)

print(f"✅ GPU 예측 완료")
```

---

## 📏 오차 메트릭

### 1. 평균 제곱 오차 (MSE)

**정의:**
```
MSE = (1/N) Σ (u_pred - u_exact)²
```

**코드:**
```python
def calculate_mse(u_pred, u_exact):
    """평균 제곱 오차 (Mean Squared Error)"""
    mse = torch.mean((u_pred - u_exact) ** 2)
    return mse.item()

# 계산
u_exact = torch.sin(torch.pi * x_test)  # 정확한 해
mse = calculate_mse(u_pred, u_exact)
print(f"MSE: {mse:.6e}")
```

### 2. 평균 절대 오차 (MAE)

**정의:**
```
MAE = (1/N) Σ |u_pred - u_exact|
```

**코드:**
```python
def calculate_mae(u_pred, u_exact):
    """평균 절대 오차 (Mean Absolute Error)"""
    mae = torch.mean(torch.abs(u_pred - u_exact))
    return mae.item()

mae = calculate_mae(u_pred, u_exact)
print(f"MAE: {mae:.6e}")
```

### 3. 상대 L² 오차

**정의:**
```
Relative L² = ||u_pred - u_exact||₂ / ||u_exact||₂
```

**코드:**
```python
def calculate_relative_l2_error(u_pred, u_exact):
    """상대 L² 오차"""
    numerator = torch.norm(u_pred - u_exact)
    denominator = torch.norm(u_exact)
    rel_error = numerator / denominator
    return rel_error.item()

rel_l2 = calculate_relative_l2_error(u_pred, u_exact)
print(f"상대 L² 오차: {rel_l2:.6f} ({rel_l2*100:.2f}%)")
```

### 4. 최대 절대 오차

**정의:**
```
Max Error = max|u_pred - u_exact|
```

**코드:**
```python
def calculate_max_error(u_pred, u_exact):
    """최대 절대 오차"""
    max_err = torch.max(torch.abs(u_pred - u_exact))
    return max_err.item()

max_err = calculate_max_error(u_pred, u_exact)
print(f"최대 절대 오차: {max_err:.6e}")
```

### 종합 메트릭 계산

```python
def compute_all_metrics(u_pred, u_exact):
    """모든 오차 메트릭 계산"""
    metrics = {
        'MSE': calculate_mse(u_pred, u_exact),
        'MAE': calculate_mae(u_pred, u_exact),
        'Relative L2': calculate_relative_l2_error(u_pred, u_exact),
        'Max Error': calculate_max_error(u_pred, u_exact)
    }
    return metrics

# 실행
metrics = compute_all_metrics(u_pred, u_exact)

print("=== 오차 메트릭 ===")
for name, value in metrics.items():
    print(f"{name:15s}: {value:.6e}")
```

---

## 📈 1D 결과 시각화

### 기본 플롯

```python
import matplotlib.pyplot as plt

plt.figure(figsize=(12, 4))

# 1. 예측 vs 정확한 해
plt.subplot(1, 3, 1)
plt.plot(x_test.numpy(), u_pred.numpy(), label='PINN 예측', linewidth=2)
plt.plot(x_test.numpy(), u_exact.numpy(), '--', label='정확한 해', linewidth=2)
plt.xlabel('x')
plt.ylabel('u(x)')
plt.title('Solution Comparison')
plt.legend()
plt.grid(True, alpha=0.3)

# 2. 점별 절대 오차
plt.subplot(1, 3, 2)
error = torch.abs(u_pred - u_exact).numpy()
plt.plot(x_test.numpy(), error, color='red', linewidth=2)
plt.xlabel('x')
plt.ylabel('|u_pred - u_exact|')
plt.title('Point-wise Absolute Error')
plt.grid(True, alpha=0.3)

# 3. 상대 오차 (%)
plt.subplot(1, 3, 3)
rel_error = (torch.abs(u_pred - u_exact) / torch.abs(u_exact) * 100).numpy()
plt.plot(x_test.numpy(), rel_error, color='orange', linewidth=2)
plt.xlabel('x')
plt.ylabel('Relative Error (%)')
plt.title('Point-wise Relative Error')
plt.grid(True, alpha=0.3)

plt.tight_layout()
plt.savefig('1d_results.png', dpi=150)
plt.show()
```

### 오차 히스토그램

```python
plt.figure(figsize=(10, 4))

# 절대 오차 분포
plt.subplot(1, 2, 1)
plt.hist(error, bins=30, edgecolor='black', alpha=0.7)
plt.xlabel('Absolute Error')
plt.ylabel('Frequency')
plt.title('Error Distribution')
plt.grid(True, alpha=0.3)

# 로그 스케일
plt.subplot(1, 2, 2)
plt.hist(error, bins=30, edgecolor='black', alpha=0.7)
plt.xlabel('Absolute Error')
plt.ylabel('Frequency')
plt.title('Error Distribution (Log Scale)')
plt.yscale('log')
plt.grid(True, alpha=0.3)

plt.tight_layout()
plt.show()
```

---

## 🗺️ 2D 결과 시각화

### 그리드 데이터 생성

```python
# 2D 테스트 그리드
x = torch.linspace(0, 1, 100)
y = torch.linspace(0, 1, 100)
X, Y = torch.meshgrid(x, y, indexing='ij')

# (100, 100) → (10000, 2)
xy = torch.stack([X.flatten(), Y.flatten()], dim=1)

# 예측
with torch.no_grad():
    U_pred = model(xy).reshape(100, 100)

print(f"2D 그리드 shape: {U_pred.shape}")
```

### Contour Plot (등고선)

```python
plt.figure(figsize=(14, 5))

# 1. PINN 예측
plt.subplot(1, 3, 1)
contour = plt.contourf(X.numpy(), Y.numpy(), U_pred.numpy(), levels=20, cmap='viridis')
plt.colorbar(contour)
plt.xlabel('x')
plt.ylabel('y')
plt.title('PINN Prediction')
plt.axis('equal')

# 2. 정확한 해
U_exact = torch.sin(torch.pi * X) * torch.sin(torch.pi * Y)
plt.subplot(1, 3, 2)
contour = plt.contourf(X.numpy(), Y.numpy(), U_exact.numpy(), levels=20, cmap='viridis')
plt.colorbar(contour)
plt.xlabel('x')
plt.ylabel('y')
plt.title('Exact Solution')
plt.axis('equal')

# 3. 절대 오차
error_2d = torch.abs(U_pred - U_exact)
plt.subplot(1, 3, 3)
contour = plt.contourf(X.numpy(), Y.numpy(), error_2d.numpy(), levels=20, cmap='hot')
plt.colorbar(contour)
plt.xlabel('x')
plt.ylabel('y')
plt.title('Absolute Error')
plt.axis('equal')

plt.tight_layout()
plt.savefig('2d_results.png', dpi=150)
plt.show()
```

### 3D Surface Plot

```python
from mpl_toolkits.mplot3d import Axes3D

fig = plt.figure(figsize=(14, 5))

# PINN 예측
ax1 = fig.add_subplot(131, projection='3d')
surf = ax1.plot_surface(X.numpy(), Y.numpy(), U_pred.numpy(), cmap='viridis', alpha=0.8)
ax1.set_xlabel('x')
ax1.set_ylabel('y')
ax1.set_zlabel('u')
ax1.set_title('PINN Prediction')
fig.colorbar(surf, ax=ax1, shrink=0.5)

# 정확한 해
ax2 = fig.add_subplot(132, projection='3d')
surf = ax2.plot_surface(X.numpy(), Y.numpy(), U_exact.numpy(), cmap='viridis', alpha=0.8)
ax2.set_xlabel('x')
ax2.set_ylabel('y')
ax2.set_zlabel('u')
ax2.set_title('Exact Solution')
fig.colorbar(surf, ax=ax2, shrink=0.5)

# 오차
ax3 = fig.add_subplot(133, projection='3d')
surf = ax3.plot_surface(X.numpy(), Y.numpy(), error_2d.numpy(), cmap='hot', alpha=0.8)
ax3.set_xlabel('x')
ax3.set_ylabel('y')
ax3.set_zlabel('error')
ax3.set_title('Absolute Error')
fig.colorbar(surf, ax=ax3, shrink=0.5)

plt.tight_layout()
plt.show()
```

---

## 📦 3D 결과 시각화

### 2D 슬라이스

```python
# 3D 데이터 생성 (예: z=0.5 평면)
x = torch.linspace(0, 1, 50)
y = torch.linspace(0, 1, 50)
X, Y = torch.meshgrid(x, y, indexing='ij')
Z = torch.ones_like(X) * 0.5  # z=0.5 고정

xyz = torch.stack([X.flatten(), Y.flatten(), Z.flatten()], dim=1)

with torch.no_grad():
    U_pred = model(xyz).reshape(50, 50)

# 시각화
plt.figure(figsize=(8, 6))
contour = plt.contourf(X.numpy(), Y.numpy(), U_pred.numpy(), levels=20, cmap='viridis')
plt.colorbar(contour, label='u(x,y,z=0.5)')
plt.xlabel('x')
plt.ylabel('y')
plt.title('3D Solution: z=0.5 Slice')
plt.axis('equal')
plt.show()
```

### 여러 슬라이스 동시에

```python
fig, axes = plt.subplots(2, 2, figsize=(12, 10))
z_values = [0.25, 0.5, 0.75, 1.0]

for ax, z_val in zip(axes.flatten(), z_values):
    Z = torch.ones_like(X) * z_val
    xyz = torch.stack([X.flatten(), Y.flatten(), Z.flatten()], dim=1)
    
    with torch.no_grad():
        U_pred = model(xyz).reshape(50, 50)
    
    contour = ax.contourf(X.numpy(), Y.numpy(), U_pred.numpy(), levels=15, cmap='viridis')
    ax.set_xlabel('x')
    ax.set_ylabel('y')
    ax.set_title(f'z = {z_val:.2f}')
    ax.axis('equal')
    fig.colorbar(contour, ax=ax)

plt.tight_layout()
plt.show()
```

---

## 🔬 잔차 분석

### PDE 잔차 계산

```python
def compute_residuals(model, x):
    """PDE 잔차 계산 (예: Poisson 방정식)"""
    x = x.requires_grad_(True)
    u = model(x)
    
    # 1차 미분
    grad_u = torch.autograd.grad(
        outputs=u,
        inputs=x,
        grad_outputs=torch.ones_like(u),
        create_graph=True
    )[0]
    
    # 2차 미분 (Laplacian)
    laplacian = 0
    for i in range(x.shape[1]):
        grad_u_i = grad_u[:, i:i+1]
        grad2_u_i = torch.autograd.grad(
            outputs=grad_u_i,
            inputs=x,
            grad_outputs=torch.ones_like(grad_u_i),
            create_graph=True
        )[0][:, i:i+1]
        laplacian += grad2_u_i
    
    # 소스 항
    f = -2 * torch.pi**2 * torch.sin(torch.pi * x[:, 0:1]) * torch.sin(torch.pi * x[:, 1:2])
    
    # 잔차
    residual = laplacian - f
    
    return residual

# 잔차 계산
residuals = compute_residuals(model, xy)
residuals_2d = residuals.reshape(100, 100)

# 시각화
plt.figure(figsize=(10, 8))
contour = plt.contourf(X.numpy(), Y.numpy(), residuals_2d.detach().numpy(), 
                       levels=20, cmap='RdBu_r')
plt.colorbar(contour, label='Residual')
plt.xlabel('x')
plt.ylabel('y')
plt.title('PDE Residual')
plt.axis('equal')
plt.show()

print(f"잔차 통계:")
print(f"  평균: {residuals.mean().item():.6e}")
print(f"  표준편차: {residuals.std().item():.6e}")
print(f"  최댓값: {residuals.max().item():.6e}")
print(f"  최솟값: {residuals.min().item():.6e}")
```

---

## 📊 종합 보고서 생성

### 자동 보고서 함수

```python
def generate_report(model, x_test, u_exact, save_path='report.png'):
    """종합 결과 보고서 생성"""
    
    # 예측
    with torch.no_grad():
        u_pred = model(x_test)
    
    # 메트릭
    metrics = compute_all_metrics(u_pred, u_exact)
    
    # 시각화
    fig = plt.figure(figsize=(16, 10))
    
    # 1. Solution
    ax1 = plt.subplot(2, 3, 1)
    ax1.plot(x_test.numpy(), u_pred.numpy(), label='PINN', linewidth=2)
    ax1.plot(x_test.numpy(), u_exact.numpy(), '--', label='Exact', linewidth=2)
    ax1.set_xlabel('x')
    ax1.set_ylabel('u(x)')
    ax1.set_title('Solution')
    ax1.legend()
    ax1.grid(True, alpha=0.3)
    
    # 2. Absolute Error
    ax2 = plt.subplot(2, 3, 2)
    error = torch.abs(u_pred - u_exact).numpy()
    ax2.plot(x_test.numpy(), error, color='red', linewidth=2)
    ax2.set_xlabel('x')
    ax2.set_ylabel('|Error|')
    ax2.set_title('Absolute Error')
    ax2.grid(True, alpha=0.3)
    
    # 3. Error Histogram
    ax3 = plt.subplot(2, 3, 3)
    ax3.hist(error, bins=30, edgecolor='black', alpha=0.7)
    ax3.set_xlabel('Error')
    ax3.set_ylabel('Frequency')
    ax3.set_title('Error Distribution')
    ax3.grid(True, alpha=0.3)
    
    # 4. Metrics Table
    ax4 = plt.subplot(2, 3, 4)
    ax4.axis('off')
    metric_text = "Metrics:\n\n"
    for name, value in metrics.items():
        metric_text += f"{name:15s}: {value:.6e}\n"
    ax4.text(0.1, 0.5, metric_text, fontsize=12, family='monospace',
             verticalalignment='center')
    
    # 5. Relative Error
    ax5 = plt.subplot(2, 3, 5)
    rel_error = (torch.abs(u_pred - u_exact) / (torch.abs(u_exact) + 1e-10) * 100).numpy()
    ax5.plot(x_test.numpy(), rel_error, color='orange', linewidth=2)
    ax5.set_xlabel('x')
    ax5.set_ylabel('Relative Error (%)')
    ax5.set_title('Relative Error')
    ax5.grid(True, alpha=0.3)
    
    # 6. Summary
    ax6 = plt.subplot(2, 3, 6)
    ax6.axis('off')
    summary = f"""
    Summary
    ────────────────
    Total Points: {len(x_test)}
    Mean Error:   {error.mean():.6e}
    Max Error:    {error.max():.6e}
    Rel. L² Error: {metrics['Relative L2']*100:.2f}%
    
    Model Parameters: {sum(p.numel() for p in model.parameters())}
    """
    ax6.text(0.1, 0.5, summary, fontsize=11, family='monospace',
             verticalalignment='center')
    
    plt.tight_layout()
    plt.savefig(save_path, dpi=150, bbox_inches='tight')
    plt.show()
    
    return metrics

# 실행
metrics = generate_report(model, x_test, u_exact, save_path='final_report.png')
```

---

## 🎯 체크포인트

다음 항목을 모두 완료했으면 다음 단계로 진행하세요!

- [ ] 모델에서 예측값 추출 성공
- [ ] 다양한 오차 메트릭 계산
- [ ] 1D 결과 시각화
- [ ] 2D 결과 시각화 (해당하는 경우)
- [ ] 잔차 분석 수행
- [ ] 종합 보고서 생성

---

## 🆘 자주 묻는 질문

### Q1: 상대 L² 오차가 얼마나 작아야 좋은 건가요?

**A:** 
- < 1%: 매우 좋음
- 1~5%: 좋음
- 5~10%: 괜찮음
- > 10%: 개선 필요

### Q2: 오차가 특정 영역에 집중되어 있어요

**A:** 다음을 시도하세요:
1. 해당 영역에 더 많은 콜로케이션 포인트 배치
2. 적응형 샘플링 사용 (7단계 참조)
3. 경계 조건 가중치 증가

### Q3: 예측값이 불연속적으로 보여요

**A:** 원인:
1. 충분히 훈련되지 않음 → 더 훈련
2. 모델이 너무 작음 → 은닉층/뉴런 증가
3. Chebyshev 차수가 너무 낮음 → degree 증가

### Q4: 결과를 CSV로 저장하고 싶어요

**A:**
```python
import pandas as pd

# 데이터프레임 생성
df = pd.DataFrame({
    'x': x_test.numpy().flatten(),
    'u_pred': u_pred.numpy().flatten(),
    'u_exact': u_exact.numpy().flatten(),
    'error': error.flatten()
})

# CSV 저장
df.to_csv('results.csv', index=False)
print("✅ results.csv 저장 완료")
```

---

## 📚 추가 자료

- **Matplotlib 갤러리:** [https://matplotlib.org/stable/gallery/index.html](https://matplotlib.org/stable/gallery/index.html)
- **Plotly (인터랙티브 플롯):** [https://plotly.com/python/](https://plotly.com/python/)

---

## 🎉 축하합니다!

결과 분석을 마스터했습니다! 기본 워크플로우를 모두 완료했습니다.

**다음 단계:**

👉 [7단계: 고급 기능으로 이동하기](07_고급기능.md) (선택)

또는 [메인 가이드로 돌아가기](../사용자_가이드.md)

---

*마지막 업데이트: 2025년 1월*
