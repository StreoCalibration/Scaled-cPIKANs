# 6ë‹¨ê³„: ê²°ê³¼ ë¶„ì„ ğŸŸ¢

> **ë‚œì´ë„:** ì´ˆê¸‰  
> **ì†Œìš” ì‹œê°„:** 30ë¶„  
> **ì‚¬ì „ ì§€ì‹:** ê¸°ë³¸ì ì¸ í†µê³„ ë° ì‹œê°í™”

---

## ğŸ¯ í•™ìŠµ ëª©í‘œ

ì´ ë‹¨ê³„ë¥¼ ë§ˆì¹˜ë©´ ë‹¤ìŒì„ í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤:

- âœ… í›ˆë ¨ëœ ëª¨ë¸ì—ì„œ ì˜ˆì¸¡ê°’ ì¶”ì¶œí•˜ê¸°
- âœ… ë‹¤ì–‘í•œ ì˜¤ì°¨ ë©”íŠ¸ë¦­ ê³„ì‚°í•˜ê¸°
- âœ… 1D/2D/3D ê²°ê³¼ ì‹œê°í™”í•˜ê¸°
- âœ… ì ë³„ ì”ì°¨ ë¶„ì„í•˜ê¸°
- âœ… ëª¨ë¸ ì„±ëŠ¥ í‰ê°€ ë° í•´ì„í•˜ê¸°

---

## ğŸ“Š ê²°ê³¼ ì¶”ì¶œ

### ê¸°ë³¸ ì˜ˆì¸¡

```python
import torch
from src.models import Scaled_cPIKAN

# í›ˆë ¨ëœ ëª¨ë¸ (ì´ë¯¸ í•™ìŠµ ì™„ë£Œ)
model.eval()  # í‰ê°€ ëª¨ë“œ

# í…ŒìŠ¤íŠ¸ í¬ì¸íŠ¸ ìƒì„±
x_test = torch.linspace(0, 1, 200).unsqueeze(1)

# ì˜ˆì¸¡ (ê·¸ë˜ë””ì–¸íŠ¸ ë¶ˆí•„ìš”)
with torch.no_grad():
    u_pred = model(x_test)

print(f"ì˜ˆì¸¡ shape: {u_pred.shape}")
print(f"ì˜ˆì¸¡ ë²”ìœ„: [{u_pred.min():.4f}, {u_pred.max():.4f}]")
```

### GPUì—ì„œ ì˜ˆì¸¡

```python
# GPU ëª¨ë¸ì¸ ê²½ìš°
device = next(model.parameters()).device
x_test = x_test.to(device)

with torch.no_grad():
    u_pred = model(x_test)
    u_pred = u_pred.cpu()  # CPUë¡œ ì´ë™ (ì‹œê°í™”ìš©)

print(f"âœ… GPU ì˜ˆì¸¡ ì™„ë£Œ")
```

---

## ğŸ“ ì˜¤ì°¨ ë©”íŠ¸ë¦­

### 1. í‰ê·  ì œê³± ì˜¤ì°¨ (MSE)

**ì •ì˜:**
```
MSE = (1/N) Î£ (u_pred - u_exact)Â²
```

**ì½”ë“œ:**
```python
def calculate_mse(u_pred, u_exact):
    """í‰ê·  ì œê³± ì˜¤ì°¨ (Mean Squared Error)"""
    mse = torch.mean((u_pred - u_exact) ** 2)
    return mse.item()

# ê³„ì‚°
u_exact = torch.sin(torch.pi * x_test)  # ì •í™•í•œ í•´
mse = calculate_mse(u_pred, u_exact)
print(f"MSE: {mse:.6e}")
```

### 2. í‰ê·  ì ˆëŒ€ ì˜¤ì°¨ (MAE)

**ì •ì˜:**
```
MAE = (1/N) Î£ |u_pred - u_exact|
```

**ì½”ë“œ:**
```python
def calculate_mae(u_pred, u_exact):
    """í‰ê·  ì ˆëŒ€ ì˜¤ì°¨ (Mean Absolute Error)"""
    mae = torch.mean(torch.abs(u_pred - u_exact))
    return mae.item()

mae = calculate_mae(u_pred, u_exact)
print(f"MAE: {mae:.6e}")
```

### 3. ìƒëŒ€ LÂ² ì˜¤ì°¨

**ì •ì˜:**
```
Relative LÂ² = ||u_pred - u_exact||â‚‚ / ||u_exact||â‚‚
```

**ì½”ë“œ:**
```python
def calculate_relative_l2_error(u_pred, u_exact):
    """ìƒëŒ€ LÂ² ì˜¤ì°¨"""
    numerator = torch.norm(u_pred - u_exact)
    denominator = torch.norm(u_exact)
    rel_error = numerator / denominator
    return rel_error.item()

rel_l2 = calculate_relative_l2_error(u_pred, u_exact)
print(f"ìƒëŒ€ LÂ² ì˜¤ì°¨: {rel_l2:.6f} ({rel_l2*100:.2f}%)")
```

### 4. ìµœëŒ€ ì ˆëŒ€ ì˜¤ì°¨

**ì •ì˜:**
```
Max Error = max|u_pred - u_exact|
```

**ì½”ë“œ:**
```python
def calculate_max_error(u_pred, u_exact):
    """ìµœëŒ€ ì ˆëŒ€ ì˜¤ì°¨"""
    max_err = torch.max(torch.abs(u_pred - u_exact))
    return max_err.item()

max_err = calculate_max_error(u_pred, u_exact)
print(f"ìµœëŒ€ ì ˆëŒ€ ì˜¤ì°¨: {max_err:.6e}")
```

### ì¢…í•© ë©”íŠ¸ë¦­ ê³„ì‚°

```python
def compute_all_metrics(u_pred, u_exact):
    """ëª¨ë“  ì˜¤ì°¨ ë©”íŠ¸ë¦­ ê³„ì‚°"""
    metrics = {
        'MSE': calculate_mse(u_pred, u_exact),
        'MAE': calculate_mae(u_pred, u_exact),
        'Relative L2': calculate_relative_l2_error(u_pred, u_exact),
        'Max Error': calculate_max_error(u_pred, u_exact)
    }
    return metrics

# ì‹¤í–‰
metrics = compute_all_metrics(u_pred, u_exact)

print("=== ì˜¤ì°¨ ë©”íŠ¸ë¦­ ===")
for name, value in metrics.items():
    print(f"{name:15s}: {value:.6e}")
```

---

## ğŸ“ˆ 1D ê²°ê³¼ ì‹œê°í™”

### ê¸°ë³¸ í”Œë¡¯

```python
import matplotlib.pyplot as plt

plt.figure(figsize=(12, 4))

# 1. ì˜ˆì¸¡ vs ì •í™•í•œ í•´
plt.subplot(1, 3, 1)
plt.plot(x_test.numpy(), u_pred.numpy(), label='PINN ì˜ˆì¸¡', linewidth=2)
plt.plot(x_test.numpy(), u_exact.numpy(), '--', label='ì •í™•í•œ í•´', linewidth=2)
plt.xlabel('x')
plt.ylabel('u(x)')
plt.title('Solution Comparison')
plt.legend()
plt.grid(True, alpha=0.3)

# 2. ì ë³„ ì ˆëŒ€ ì˜¤ì°¨
plt.subplot(1, 3, 2)
error = torch.abs(u_pred - u_exact).numpy()
plt.plot(x_test.numpy(), error, color='red', linewidth=2)
plt.xlabel('x')
plt.ylabel('|u_pred - u_exact|')
plt.title('Point-wise Absolute Error')
plt.grid(True, alpha=0.3)

# 3. ìƒëŒ€ ì˜¤ì°¨ (%)
plt.subplot(1, 3, 3)
rel_error = (torch.abs(u_pred - u_exact) / torch.abs(u_exact) * 100).numpy()
plt.plot(x_test.numpy(), rel_error, color='orange', linewidth=2)
plt.xlabel('x')
plt.ylabel('Relative Error (%)')
plt.title('Point-wise Relative Error')
plt.grid(True, alpha=0.3)

plt.tight_layout()
plt.savefig('1d_results.png', dpi=150)
plt.show()
```

### ì˜¤ì°¨ íˆìŠ¤í† ê·¸ë¨

```python
plt.figure(figsize=(10, 4))

# ì ˆëŒ€ ì˜¤ì°¨ ë¶„í¬
plt.subplot(1, 2, 1)
plt.hist(error, bins=30, edgecolor='black', alpha=0.7)
plt.xlabel('Absolute Error')
plt.ylabel('Frequency')
plt.title('Error Distribution')
plt.grid(True, alpha=0.3)

# ë¡œê·¸ ìŠ¤ì¼€ì¼
plt.subplot(1, 2, 2)
plt.hist(error, bins=30, edgecolor='black', alpha=0.7)
plt.xlabel('Absolute Error')
plt.ylabel('Frequency')
plt.title('Error Distribution (Log Scale)')
plt.yscale('log')
plt.grid(True, alpha=0.3)

plt.tight_layout()
plt.show()
```

---

## ğŸ—ºï¸ 2D ê²°ê³¼ ì‹œê°í™”

### ê·¸ë¦¬ë“œ ë°ì´í„° ìƒì„±

```python
# 2D í…ŒìŠ¤íŠ¸ ê·¸ë¦¬ë“œ
x = torch.linspace(0, 1, 100)
y = torch.linspace(0, 1, 100)
X, Y = torch.meshgrid(x, y, indexing='ij')

# (100, 100) â†’ (10000, 2)
xy = torch.stack([X.flatten(), Y.flatten()], dim=1)

# ì˜ˆì¸¡
with torch.no_grad():
    U_pred = model(xy).reshape(100, 100)

print(f"2D ê·¸ë¦¬ë“œ shape: {U_pred.shape}")
```

### Contour Plot (ë“±ê³ ì„ )

```python
plt.figure(figsize=(14, 5))

# 1. PINN ì˜ˆì¸¡
plt.subplot(1, 3, 1)
contour = plt.contourf(X.numpy(), Y.numpy(), U_pred.numpy(), levels=20, cmap='viridis')
plt.colorbar(contour)
plt.xlabel('x')
plt.ylabel('y')
plt.title('PINN Prediction')
plt.axis('equal')

# 2. ì •í™•í•œ í•´
U_exact = torch.sin(torch.pi * X) * torch.sin(torch.pi * Y)
plt.subplot(1, 3, 2)
contour = plt.contourf(X.numpy(), Y.numpy(), U_exact.numpy(), levels=20, cmap='viridis')
plt.colorbar(contour)
plt.xlabel('x')
plt.ylabel('y')
plt.title('Exact Solution')
plt.axis('equal')

# 3. ì ˆëŒ€ ì˜¤ì°¨
error_2d = torch.abs(U_pred - U_exact)
plt.subplot(1, 3, 3)
contour = plt.contourf(X.numpy(), Y.numpy(), error_2d.numpy(), levels=20, cmap='hot')
plt.colorbar(contour)
plt.xlabel('x')
plt.ylabel('y')
plt.title('Absolute Error')
plt.axis('equal')

plt.tight_layout()
plt.savefig('2d_results.png', dpi=150)
plt.show()
```

### 3D Surface Plot

```python
from mpl_toolkits.mplot3d import Axes3D

fig = plt.figure(figsize=(14, 5))

# PINN ì˜ˆì¸¡
ax1 = fig.add_subplot(131, projection='3d')
surf = ax1.plot_surface(X.numpy(), Y.numpy(), U_pred.numpy(), cmap='viridis', alpha=0.8)
ax1.set_xlabel('x')
ax1.set_ylabel('y')
ax1.set_zlabel('u')
ax1.set_title('PINN Prediction')
fig.colorbar(surf, ax=ax1, shrink=0.5)

# ì •í™•í•œ í•´
ax2 = fig.add_subplot(132, projection='3d')
surf = ax2.plot_surface(X.numpy(), Y.numpy(), U_exact.numpy(), cmap='viridis', alpha=0.8)
ax2.set_xlabel('x')
ax2.set_ylabel('y')
ax2.set_zlabel('u')
ax2.set_title('Exact Solution')
fig.colorbar(surf, ax=ax2, shrink=0.5)

# ì˜¤ì°¨
ax3 = fig.add_subplot(133, projection='3d')
surf = ax3.plot_surface(X.numpy(), Y.numpy(), error_2d.numpy(), cmap='hot', alpha=0.8)
ax3.set_xlabel('x')
ax3.set_ylabel('y')
ax3.set_zlabel('error')
ax3.set_title('Absolute Error')
fig.colorbar(surf, ax=ax3, shrink=0.5)

plt.tight_layout()
plt.show()
```

---

## ğŸ“¦ 3D ê²°ê³¼ ì‹œê°í™”

### 2D ìŠ¬ë¼ì´ìŠ¤

```python
# 3D ë°ì´í„° ìƒì„± (ì˜ˆ: z=0.5 í‰ë©´)
x = torch.linspace(0, 1, 50)
y = torch.linspace(0, 1, 50)
X, Y = torch.meshgrid(x, y, indexing='ij')
Z = torch.ones_like(X) * 0.5  # z=0.5 ê³ ì •

xyz = torch.stack([X.flatten(), Y.flatten(), Z.flatten()], dim=1)

with torch.no_grad():
    U_pred = model(xyz).reshape(50, 50)

# ì‹œê°í™”
plt.figure(figsize=(8, 6))
contour = plt.contourf(X.numpy(), Y.numpy(), U_pred.numpy(), levels=20, cmap='viridis')
plt.colorbar(contour, label='u(x,y,z=0.5)')
plt.xlabel('x')
plt.ylabel('y')
plt.title('3D Solution: z=0.5 Slice')
plt.axis('equal')
plt.show()
```

### ì—¬ëŸ¬ ìŠ¬ë¼ì´ìŠ¤ ë™ì‹œì—

```python
fig, axes = plt.subplots(2, 2, figsize=(12, 10))
z_values = [0.25, 0.5, 0.75, 1.0]

for ax, z_val in zip(axes.flatten(), z_values):
    Z = torch.ones_like(X) * z_val
    xyz = torch.stack([X.flatten(), Y.flatten(), Z.flatten()], dim=1)
    
    with torch.no_grad():
        U_pred = model(xyz).reshape(50, 50)
    
    contour = ax.contourf(X.numpy(), Y.numpy(), U_pred.numpy(), levels=15, cmap='viridis')
    ax.set_xlabel('x')
    ax.set_ylabel('y')
    ax.set_title(f'z = {z_val:.2f}')
    ax.axis('equal')
    fig.colorbar(contour, ax=ax)

plt.tight_layout()
plt.show()
```

---

## ğŸ”¬ ì”ì°¨ ë¶„ì„

### PDE ì”ì°¨ ê³„ì‚°

```python
def compute_residuals(model, x):
    """PDE ì”ì°¨ ê³„ì‚° (ì˜ˆ: Poisson ë°©ì •ì‹)"""
    x = x.requires_grad_(True)
    u = model(x)
    
    # 1ì°¨ ë¯¸ë¶„
    grad_u = torch.autograd.grad(
        outputs=u,
        inputs=x,
        grad_outputs=torch.ones_like(u),
        create_graph=True
    )[0]
    
    # 2ì°¨ ë¯¸ë¶„ (Laplacian)
    laplacian = 0
    for i in range(x.shape[1]):
        grad_u_i = grad_u[:, i:i+1]
        grad2_u_i = torch.autograd.grad(
            outputs=grad_u_i,
            inputs=x,
            grad_outputs=torch.ones_like(grad_u_i),
            create_graph=True
        )[0][:, i:i+1]
        laplacian += grad2_u_i
    
    # ì†ŒìŠ¤ í•­
    f = -2 * torch.pi**2 * torch.sin(torch.pi * x[:, 0:1]) * torch.sin(torch.pi * x[:, 1:2])
    
    # ì”ì°¨
    residual = laplacian - f
    
    return residual

# ì”ì°¨ ê³„ì‚°
residuals = compute_residuals(model, xy)
residuals_2d = residuals.reshape(100, 100)

# ì‹œê°í™”
plt.figure(figsize=(10, 8))
contour = plt.contourf(X.numpy(), Y.numpy(), residuals_2d.detach().numpy(), 
                       levels=20, cmap='RdBu_r')
plt.colorbar(contour, label='Residual')
plt.xlabel('x')
plt.ylabel('y')
plt.title('PDE Residual')
plt.axis('equal')
plt.show()

print(f"ì”ì°¨ í†µê³„:")
print(f"  í‰ê· : {residuals.mean().item():.6e}")
print(f"  í‘œì¤€í¸ì°¨: {residuals.std().item():.6e}")
print(f"  ìµœëŒ“ê°’: {residuals.max().item():.6e}")
print(f"  ìµœì†Ÿê°’: {residuals.min().item():.6e}")
```

---

## ğŸ“Š ì¢…í•© ë³´ê³ ì„œ ìƒì„±

### ìë™ ë³´ê³ ì„œ í•¨ìˆ˜

```python
def generate_report(model, x_test, u_exact, save_path='report.png'):
    """ì¢…í•© ê²°ê³¼ ë³´ê³ ì„œ ìƒì„±"""
    
    # ì˜ˆì¸¡
    with torch.no_grad():
        u_pred = model(x_test)
    
    # ë©”íŠ¸ë¦­
    metrics = compute_all_metrics(u_pred, u_exact)
    
    # ì‹œê°í™”
    fig = plt.figure(figsize=(16, 10))
    
    # 1. Solution
    ax1 = plt.subplot(2, 3, 1)
    ax1.plot(x_test.numpy(), u_pred.numpy(), label='PINN', linewidth=2)
    ax1.plot(x_test.numpy(), u_exact.numpy(), '--', label='Exact', linewidth=2)
    ax1.set_xlabel('x')
    ax1.set_ylabel('u(x)')
    ax1.set_title('Solution')
    ax1.legend()
    ax1.grid(True, alpha=0.3)
    
    # 2. Absolute Error
    ax2 = plt.subplot(2, 3, 2)
    error = torch.abs(u_pred - u_exact).numpy()
    ax2.plot(x_test.numpy(), error, color='red', linewidth=2)
    ax2.set_xlabel('x')
    ax2.set_ylabel('|Error|')
    ax2.set_title('Absolute Error')
    ax2.grid(True, alpha=0.3)
    
    # 3. Error Histogram
    ax3 = plt.subplot(2, 3, 3)
    ax3.hist(error, bins=30, edgecolor='black', alpha=0.7)
    ax3.set_xlabel('Error')
    ax3.set_ylabel('Frequency')
    ax3.set_title('Error Distribution')
    ax3.grid(True, alpha=0.3)
    
    # 4. Metrics Table
    ax4 = plt.subplot(2, 3, 4)
    ax4.axis('off')
    metric_text = "Metrics:\n\n"
    for name, value in metrics.items():
        metric_text += f"{name:15s}: {value:.6e}\n"
    ax4.text(0.1, 0.5, metric_text, fontsize=12, family='monospace',
             verticalalignment='center')
    
    # 5. Relative Error
    ax5 = plt.subplot(2, 3, 5)
    rel_error = (torch.abs(u_pred - u_exact) / (torch.abs(u_exact) + 1e-10) * 100).numpy()
    ax5.plot(x_test.numpy(), rel_error, color='orange', linewidth=2)
    ax5.set_xlabel('x')
    ax5.set_ylabel('Relative Error (%)')
    ax5.set_title('Relative Error')
    ax5.grid(True, alpha=0.3)
    
    # 6. Summary
    ax6 = plt.subplot(2, 3, 6)
    ax6.axis('off')
    summary = f"""
    Summary
    â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    Total Points: {len(x_test)}
    Mean Error:   {error.mean():.6e}
    Max Error:    {error.max():.6e}
    Rel. LÂ² Error: {metrics['Relative L2']*100:.2f}%
    
    Model Parameters: {sum(p.numel() for p in model.parameters())}
    """
    ax6.text(0.1, 0.5, summary, fontsize=11, family='monospace',
             verticalalignment='center')
    
    plt.tight_layout()
    plt.savefig(save_path, dpi=150, bbox_inches='tight')
    plt.show()
    
    return metrics

# ì‹¤í–‰
metrics = generate_report(model, x_test, u_exact, save_path='final_report.png')
```

---

## ğŸ¯ ì²´í¬í¬ì¸íŠ¸

ë‹¤ìŒ í•­ëª©ì„ ëª¨ë‘ ì™„ë£Œí–ˆìœ¼ë©´ ë‹¤ìŒ ë‹¨ê³„ë¡œ ì§„í–‰í•˜ì„¸ìš”!

- [ ] ëª¨ë¸ì—ì„œ ì˜ˆì¸¡ê°’ ì¶”ì¶œ ì„±ê³µ
- [ ] ë‹¤ì–‘í•œ ì˜¤ì°¨ ë©”íŠ¸ë¦­ ê³„ì‚°
- [ ] 1D ê²°ê³¼ ì‹œê°í™”
- [ ] 2D ê²°ê³¼ ì‹œê°í™” (í•´ë‹¹í•˜ëŠ” ê²½ìš°)
- [ ] ì”ì°¨ ë¶„ì„ ìˆ˜í–‰
- [ ] ì¢…í•© ë³´ê³ ì„œ ìƒì„±

---

## ğŸ†˜ ìì£¼ ë¬»ëŠ” ì§ˆë¬¸

### Q1: ìƒëŒ€ LÂ² ì˜¤ì°¨ê°€ ì–¼ë§ˆë‚˜ ì‘ì•„ì•¼ ì¢‹ì€ ê±´ê°€ìš”?

**A:** 
- < 1%: ë§¤ìš° ì¢‹ìŒ
- 1~5%: ì¢‹ìŒ
- 5~10%: ê´œì°®ìŒ
- > 10%: ê°œì„  í•„ìš”

### Q2: ì˜¤ì°¨ê°€ íŠ¹ì • ì˜ì—­ì— ì§‘ì¤‘ë˜ì–´ ìˆì–´ìš”

**A:** ë‹¤ìŒì„ ì‹œë„í•˜ì„¸ìš”:
1. í•´ë‹¹ ì˜ì—­ì— ë” ë§ì€ ì½œë¡œì¼€ì´ì…˜ í¬ì¸íŠ¸ ë°°ì¹˜
2. ì ì‘í˜• ìƒ˜í”Œë§ ì‚¬ìš© (7ë‹¨ê³„ ì°¸ì¡°)
3. ê²½ê³„ ì¡°ê±´ ê°€ì¤‘ì¹˜ ì¦ê°€

### Q3: ì˜ˆì¸¡ê°’ì´ ë¶ˆì—°ì†ì ìœ¼ë¡œ ë³´ì—¬ìš”

**A:** ì›ì¸:
1. ì¶©ë¶„íˆ í›ˆë ¨ë˜ì§€ ì•ŠìŒ â†’ ë” í›ˆë ¨
2. ëª¨ë¸ì´ ë„ˆë¬´ ì‘ìŒ â†’ ì€ë‹‰ì¸µ/ë‰´ëŸ° ì¦ê°€
3. Chebyshev ì°¨ìˆ˜ê°€ ë„ˆë¬´ ë‚®ìŒ â†’ degree ì¦ê°€

### Q4: ê²°ê³¼ë¥¼ CSVë¡œ ì €ì¥í•˜ê³  ì‹¶ì–´ìš”

**A:**
```python
import pandas as pd

# ë°ì´í„°í”„ë ˆì„ ìƒì„±
df = pd.DataFrame({
    'x': x_test.numpy().flatten(),
    'u_pred': u_pred.numpy().flatten(),
    'u_exact': u_exact.numpy().flatten(),
    'error': error.flatten()
})

# CSV ì €ì¥
df.to_csv('results.csv', index=False)
print("âœ… results.csv ì €ì¥ ì™„ë£Œ")
```

---

## ğŸ“š ì¶”ê°€ ìë£Œ

- **Matplotlib ê°¤ëŸ¬ë¦¬:** [https://matplotlib.org/stable/gallery/index.html](https://matplotlib.org/stable/gallery/index.html)
- **Plotly (ì¸í„°ë™í‹°ë¸Œ í”Œë¡¯):** [https://plotly.com/python/](https://plotly.com/python/)

---

## ğŸ‰ ì¶•í•˜í•©ë‹ˆë‹¤!

ê²°ê³¼ ë¶„ì„ì„ ë§ˆìŠ¤í„°í–ˆìŠµë‹ˆë‹¤! ê¸°ë³¸ ì›Œí¬í”Œë¡œìš°ë¥¼ ëª¨ë‘ ì™„ë£Œí–ˆìŠµë‹ˆë‹¤.

**ë‹¤ìŒ ë‹¨ê³„:**

ğŸ‘‰ [7ë‹¨ê³„: ê³ ê¸‰ ê¸°ëŠ¥ìœ¼ë¡œ ì´ë™í•˜ê¸°](07_ê³ ê¸‰ê¸°ëŠ¥.md) (ì„ íƒ)

ë˜ëŠ” [ë©”ì¸ ê°€ì´ë“œë¡œ ëŒì•„ê°€ê¸°](../ì‚¬ìš©ì_ê°€ì´ë“œ.md)

---

*ë§ˆì§€ë§‰ ì—…ë°ì´íŠ¸: 2025ë…„ 1ì›”*
