# 위상 천이 간섭법 (Phase Shifting Interferometry) 완전 가이드 🌊

> **난이도:** 중급  
> **소요 시간:** 90분  
> **사전 지식:** 파동 기초, 삼각함수, Python

---

## 🎯 학습 목표

이 가이드를 마치면 다음을 할 수 있습니다:

- ✅ 위상 천이 간섭법(PSI)의 물리적 원리 이해하기
- ✅ 4-step PSI 알고리즘 구현하기
- ✅ 다중 파장 기법으로 측정 범위 확장하기
- ✅ Bucket 이미지에서 높이 복원하는 방법 이해하기
- ✅ PINN에서 물리 모델을 손실 함수에 통합하는 방법 익히기

---

## 📋 목차

1. [간섭계란 무엇인가?](#간섭계란-무엇인가)
2. [위상과 높이의 관계](#위상과-높이의-관계)
3. [4-Step 위상 천이 간섭법](#4-step-위상-천이-간섭법)
4. [Bucket 이미지 생성 원리](#bucket-이미지-생성-원리)
5. [다중 파장 기법](#다중-파장-기법)
6. [데이터 생성 구현](#데이터-생성-구현)
7. [Physics-Informed Loss 설계](#physics-informed-loss-설계)
8. [전체 워크플로우](#전체-워크플로우)
9. [실습 예제](#실습-예제)

---

## 간섭계란 무엇인가?

### 🌊 파동의 간섭 현상

두 개의 파동이 만나면 **간섭(interference)** 현상이 발생합니다.

```
파동 1: ~~~~~~~~~~~
파동 2:    ~~~~~~~~~~~
         ↓
결과:   ∿∿∿∿∿∿∿∿∿∿∿
      (보강 간섭)

파동 1: ~~~~~~~~~~~
파동 2:    ∪∪∪∪∪∪∪∪∪∪
         ↓
결과:   ___________
      (상쇄 간섭)
```

### 💡 간섭계의 원리

**레이저 간섭계**는 이 원리를 이용해 극미세한 높이 변화를 측정합니다!

```
        레이저
          ↓
      ┌───┴───┐
      │ 빔분할기│
      └─┬───┬─┘
        │   │
     기준면 측정면
        │   │ (높이 h)
        │   │
      반사광 반사광
        │   │
        └─┬─┘
       검출기
        ↓
    간섭 패턴
```

**핵심 아이디어:**
- 측정면의 높이가 변하면 → 빛의 경로 길이가 변함
- 경로 길이 차이 → 위상 차이 발생
- 위상 차이 → 간섭 패턴의 밝기 변화

---

## 위상과 높이의 관계

### 📐 수학적 관계식

표면 높이 `h`와 위상 `φ` 사이의 관계:

```
φ = (4π/λ) × h
```

여기서:
- `φ`: 위상 (라디안)
- `λ`: 레이저 파장 (마이크로미터)
- `h`: 표면 높이 (마이크로미터)
- `4π`: 왕복 경로 (2×2π)

### 🔄 역산 공식

높이를 계산하려면:

```
h = (λ/(4π)) × φ
```

### 💡 실제 예시

**파장 λ = 632.8 nm (He-Ne 레이저)**
```
높이 h = 100 nm일 때
φ = (4π / 632.8nm) × 100nm
  = 1.983 라디안
  ≈ 113.6°
```

### 🎨 간섭 강도 공식

측정되는 빛의 강도:

```
I(φ) = A + B × cos(φ)
```

여기서:
- `A`: 배경 강도 (DC 성분)
- `B`: 간섭 진폭 (AC 성분)
- `φ`: 위상

**그래프:**
```
I
│     ╱＼      ╱＼
│    ╱  ＼    ╱  ＼
A+B ─────────────────
│   ╱    ＼  ╱    ＼
A  ─────────────────── (평균)
│  ╱      ＼╱      ＼
A-B ──────────────────
│
└────────────────────> φ
    0   π   2π  3π
```

---

## 4-Step 위상 천이 간섭법

### 🎯 문제점

**단일 측정의 한계:**
- `I = A + B×cos(φ)` 에서 `A`, `B`, `φ` 모두 미지수!
- 방정식 1개, 미지수 3개 → 해가 무한개

**해결책: 위상을 변화시키며 여러 번 측정!**

### 📷 4-Step PSI 알고리즘

4번 측정하며 **위상 천이** `δ`를 추가:

```
I₀ = A + B × cos(φ + 0°)     [δ = 0°]
I₁ = A + B × cos(φ + 90°)    [δ = π/2]
I₂ = A + B × cos(φ + 180°)   [δ = π]
I₃ = A + B × cos(φ + 270°)   [δ = 3π/2]
```

### 🧮 위상 복원 공식

4개의 측정값으로부터 위상 계산:

```
φ = atan2(I₃ - I₁, I₀ - I₂)
```

**유도 과정:**
```
I₀ - I₂ = 2B × cos(φ)
I₃ - I₁ = 2B × sin(φ)

tan(φ) = (I₃ - I₁)/(I₀ - I₂)
φ = atan2(I₃ - I₁, I₀ - I₂)
```

### 💻 Python 구현

```python
import numpy as np

def phase_from_4step(I0, I1, I2, I3):
    """
    4-step PSI로 위상 복원
    
    Args:
        I0, I1, I2, I3: 4개의 bucket 이미지 (numpy arrays)
    
    Returns:
        phase: 복원된 위상 (라디안)
    """
    numerator = I3 - I1
    denominator = I0 - I2
    phase = np.arctan2(numerator, denominator)
    return phase

# 예시
I0 = 128 + 100 * np.cos(1.5)
I1 = 128 + 100 * np.cos(1.5 + np.pi/2)
I2 = 128 + 100 * np.cos(1.5 + np.pi)
I3 = 128 + 100 * np.cos(1.5 + 3*np.pi/2)

phi_recovered = phase_from_4step(I0, I1, I2, I3)
print(f"원래 위상: 1.5 rad")
print(f"복원 위상: {phi_recovered:.4f} rad")
```

---

## Bucket 이미지 생성 원리

### 🪣 "Bucket"이란?

**Bucket 이미지**: 각 위상 천이 단계에서 촬영된 간섭 패턴 이미지

```
┌─────────────┐  ┌─────────────┐  ┌─────────────┐  ┌─────────────┐
│ Bucket 0    │  │ Bucket 1    │  │ Bucket 2    │  │ Bucket 3    │
│ (δ = 0°)    │  │ (δ = 90°)   │  │ (δ = 180°)  │  │ (δ = 270°)  │
│  ○ ● ○ ●    │  │  ● ○ ● ○    │  │  ○ ● ○ ●    │  │  ● ○ ● ○    │
│  ● ○ ● ○    │  │  ○ ● ○ ●    │  │  ● ○ ● ○    │  │  ○ ● ○ ●    │
└─────────────┘  └─────────────┘  └─────────────┘  └─────────────┘
```

### 🔢 수치적 생성

**단일 픽셀에서:**
```python
A = 128  # 배경 강도
B = 100  # 간섭 진폭
h = 0.5  # 높이 (μm)
λ = 5.0  # 파장 (μm)

# 위상 계산
φ = (4 * np.pi / λ) * h

# 4개의 위상 천이
deltas = [0, np.pi/2, np.pi, 3*np.pi/2]

# Bucket 값 생성
buckets = [A + B * np.cos(φ + δ) for δ in deltas]
print(f"Bucket 값들: {buckets}")
```

### 🖼️ 이미지 전체 생성

```python
def generate_buckets(height_map, wavelength, A=128, B=100):
    """
    높이 맵으로부터 4개의 bucket 이미지 생성
    
    Args:
        height_map: (H, W) 높이 맵 (μm)
        wavelength: 레이저 파장 (μm)
        A: 배경 강도
        B: 간섭 진폭
    
    Returns:
        buckets: (4, H, W) bucket 이미지 배열
    """
    # 위상 계산
    phase = (4 * np.pi / wavelength) * height_map
    
    # 4개의 위상 천이
    deltas = np.array([0, np.pi/2, np.pi, 3*np.pi/2])
    
    # Bucket 이미지 생성
    buckets = []
    for delta in deltas:
        intensity = A + B * np.cos(phase + delta)
        buckets.append(intensity)
    
    return np.array(buckets)

# 예시: 간단한 경사면
H, W = 128, 128
x = np.linspace(0, 10, W)
y = np.linspace(0, 10, H)
X, Y = np.meshgrid(x, y)
height_map = 0.5 * X  # 경사면 (0 ~ 5 μm)

buckets = generate_buckets(height_map, wavelength=5.0)
print(f"생성된 bucket 형태: {buckets.shape}")
```

---

## 다중 파장 기법

### 🌈 왜 여러 파장이 필요한가?

**단일 파장의 문제점:**
- `atan2`는 `-π ~ π` 범위만 반환 (wrapping 발생)
- 측정 가능한 최대 높이 제한: `h_max = λ/4`

**예시:**
```
λ = 5.0 μm → h_max = 1.25 μm
λ = 0.632 μm → h_max = 0.158 μm
```

### 📏 다중 파장 해결책

**4개의 서로 다른 파장 사용:**
```
λ₁ = 5.000 μm  (적외선)
λ₂ = 5.500 μm
λ₃ = 6.050 μm
λ₄ = 6.655 μm
```

**원리:**
- 각 파장마다 wrapping 주기가 다름
- 여러 측정을 결합하여 **위상 언래핑 (unwrapping)** 수행
- 측정 범위 대폭 확장

### 🔧 합성 파장

두 파장의 조합으로 더 긴 **합성 파장** 생성:

```
Λ₁₂ = (λ₁ × λ₂) / |λ₁ - λ₂|
```

**예시:**
```
λ₁ = 5.0 μm, λ₂ = 5.5 μm
Λ₁₂ = (5.0 × 5.5) / 0.5 = 55 μm

측정 범위: 55/4 = 13.75 μm (단일 파장의 11배!)
```

### 💻 다중 파장 데이터 생성

```python
def generate_multiwavelength_buckets(height_map, wavelengths, num_buckets=4):
    """
    다중 파장 bucket 이미지 생성
    
    Args:
        height_map: (H, W) 높이 맵
        wavelengths: 파장 리스트 [λ₁, λ₂, λ₃, λ₄]
        num_buckets: 각 파장당 bucket 수
    
    Returns:
        all_buckets: (num_wavelengths * num_buckets, H, W)
    """
    all_buckets = []
    
    for wavelength in wavelengths:
        buckets = generate_buckets(height_map, wavelength)
        all_buckets.append(buckets)
    
    # (4 wavelengths, 4 buckets, H, W) → (16, H, W)
    all_buckets = np.concatenate(all_buckets, axis=0)
    
    return all_buckets

# 예시
wavelengths = [5.0, 5.5, 6.05, 6.655]
buckets_multi = generate_multiwavelength_buckets(height_map, wavelengths)
print(f"다중 파장 buckets 형태: {buckets_multi.shape}")  # (16, 128, 128)
```

---

## 데이터 생성 구현

### 📦 프로젝트의 데이터 생성기

`src/data_generator.py`의 구현:

```python
import numpy as np

DEFAULT_WAVELENGTHS = [5.0, 5.5, 6.05, 6.655]  # μm

def generate_synthetic_data(
    shape=(128, 128),
    wavelengths=None,
    num_buckets=4,
    save_path="reconstruction_data",
    output_format='bmp'
):
    """
    합성 데이터 생성 (높이 맵 + bucket 이미지)
    
    Args:
        shape: 이미지 크기 (H, W)
        wavelengths: 레이저 파장 리스트
        num_buckets: 각 레이저당 bucket 수
        save_path: 저장 경로
        output_format: 출력 형식 ('bmp', 'png', 'npy')
    
    Returns:
        ground_truth_height: (H, W) 높이 맵
        bucket_images: (num_lasers, num_buckets, H, W)
    """
    if wavelengths is None:
        wavelengths = DEFAULT_WAVELENGTHS
    
    height, width = shape
    num_lasers = len(wavelengths)
    
    # --- 1. Ground Truth 높이 맵 생성 ---
    x = np.linspace(-1, 1, width)
    y = np.linspace(-1, 1, height)
    xx, yy = np.meshgrid(x, y)
    
    # 복잡한 표면 생성 (가우시안 피크 + 평면 + 원뿔)
    peak = 15.0 * np.exp(-((xx - 0.2)**2 + (yy + 0.3)**2) / 0.2)
    plane = 5.0 * xx + 2.5 * yy
    cone = 10.0 * np.sqrt((xx + 0.5)**2 + (yy - 0.4)**2)
    ground_truth_height = peak + plane + cone
    
    print(f"생성된 높이 범위: [{ground_truth_height.min():.2f}, {ground_truth_height.max():.2f}] μm")
    
    # --- 2. 각 레이저에 대한 Bucket 이미지 생성 ---
    all_bucket_images = []
    deltas = np.linspace(0, 2 * np.pi, num_buckets, endpoint=False)
    
    A, B = 128, 100  # 강도 파라미터
    
    for i, wavelength in enumerate(wavelengths):
        # 위상 계산
        phase = (4 * np.pi * ground_truth_height) / wavelength
        
        # Bucket 생성
        buckets = [A + B * np.cos(phase + delta) for delta in deltas]
        laser_buckets = np.stack(buckets, axis=0)
        all_bucket_images.append(laser_buckets)
        
        print(f"레이저 {i+1} (λ={wavelength} μm): {num_buckets}개 bucket 생성")
    
    # (num_lasers, num_buckets, H, W)
    bucket_images_np = np.array(all_bucket_images)
    
    return ground_truth_height, bucket_images_np
```

### 🎨 시각화 함수

```python
import matplotlib.pyplot as plt

def visualize_psi_data(height_map, buckets, wavelength_idx=0):
    """PSI 데이터 시각화"""
    fig, axes = plt.subplots(2, 3, figsize=(15, 10))
    
    # 높이 맵
    im0 = axes[0, 0].imshow(height_map, cmap='viridis')
    axes[0, 0].set_title('Ground Truth Height Map')
    plt.colorbar(im0, ax=axes[0, 0])
    
    # 4개의 bucket 이미지
    buckets_laser = buckets[wavelength_idx]
    for i in range(4):
        ax = axes[i//2, i%2 + 1] if i < 2 else axes[(i-2)//2 + 1, (i-2)%2]
        im = ax.imshow(buckets_laser[i], cmap='gray')
        ax.set_title(f'Bucket {i} (δ={i*90}°)')
        plt.colorbar(im, ax=ax)
    
    # 위상 맵
    phase = np.arctan2(
        buckets_laser[3] - buckets_laser[1],
        buckets_laser[0] - buckets_laser[2]
    )
    im5 = axes[1, 2].imshow(phase, cmap='hsv')
    axes[1, 2].set_title('Recovered Phase (wrapped)')
    plt.colorbar(im5, ax=axes[1, 2])
    
    plt.tight_layout()
    plt.show()
```

---

## Physics-Informed Loss 설계

### 🎯 핵심 아이디어

**순방향 물리 모델을 손실 함수에 통합!**

```
훈련 루프:
  1. 모델이 높이 예측: h_pred = Model(buckets)
  2. 물리 모델로 bucket 재생성: buckets_pred = Physics(h_pred)
  3. 실제 bucket과 비교: Loss = MSE(buckets_pred, buckets_real)
  4. 역전파로 모델 업데이트
```

### 📐 수학적 정의

**데이터 일관성 손실:**

```
L_data = (1/N) Σᵢ Σⱼ |I_pred(i,j) - I_real(i,j)|²
```

여기서:
- `i`: 레이저 인덱스 (1~4)
- `j`: bucket 인덱스 (1~4)
- `I_pred`: 예측 높이로부터 재생성된 bucket
- `I_real`: 실제 측정 bucket

**전체 손실:**

```
L_total = L_data + λ_smooth × L_smooth
```

`L_smooth`: 평활도 정규화 (Laplacian penalty)

### 💻 PyTorch 구현

```python
import torch
import torch.nn as nn
import numpy as np

class PSI_PhysicsLoss(nn.Module):
    """
    위상 천이 간섭법 기반 물리 손실 함수
    """
    def __init__(self, wavelengths, num_buckets=4, smoothness_weight=1e-4):
        super().__init__()
        self.wavelengths = torch.tensor(wavelengths, dtype=torch.float32).view(-1, 1, 1, 1)
        
        # 위상 천이 각도
        deltas = torch.arange(num_buckets, dtype=torch.float32) * (2 * np.pi / num_buckets)
        self.deltas = deltas.view(1, num_buckets, 1, 1)
        
        self.smoothness_weight = smoothness_weight
        self.mse_loss = nn.MSELoss()
        
        # Laplacian 커널
        laplacian_kernel = torch.tensor([[0, 1, 0], [1, -4, 1], [0, 1, 0]], dtype=torch.float32)
        self.laplacian_kernel = laplacian_kernel.view(1, 1, 3, 3)
    
    def forward(self, predicted_height, input_buckets):
        """
        손실 계산
        
        Args:
            predicted_height: (N, 1, H, W) 예측된 높이 맵
            input_buckets: (N, 16, H, W) 실제 bucket 이미지
        
        Returns:
            total_loss: 총 손실
        """
        device = predicted_height.device
        self.wavelengths = self.wavelengths.to(device)
        self.deltas = self.deltas.to(device)
        self.laplacian_kernel = self.laplacian_kernel.to(device)
        
        # --- 1. 데이터 일관성 손실 ---
        # 예측 높이 → 위상 → bucket 재생성
        height_expanded = predicted_height.unsqueeze(1)  # (N, 1, 1, H, W)
        
        # 위상 계산: φ = (4π/λ) × h
        phase = (4 * np.pi / self.wavelengths) * height_expanded  # (N, num_lasers, 1, H, W)
        
        # 위상 천이 추가
        phase_with_shifts = phase + self.deltas  # (N, num_lasers, num_buckets, H, W)
        
        # Bucket 재생성: I = A + B×cos(φ + δ)
        A, B = 128, 100
        predicted_buckets = A + B * torch.cos(phase_with_shifts)
        
        # 형태 변환 (N, num_lasers, num_buckets, H, W) → (N, 16, H, W)
        predicted_buckets = predicted_buckets.view_as(input_buckets)
        
        # MSE 손실
        loss_data = self.mse_loss(predicted_buckets, input_buckets)
        
        # --- 2. 평활도 정규화 ---
        laplacian = torch.nn.functional.conv2d(predicted_height, self.laplacian_kernel, padding=1)
        loss_smooth = self.mse_loss(laplacian, torch.zeros_like(laplacian))
        
        # --- 총 손실 ---
        total_loss = loss_data + self.smoothness_weight * loss_smooth
        
        # 메트릭 저장
        self.metrics = {
            "loss_total": total_loss.item(),
            "loss_data": loss_data.item(),
            "loss_smooth": loss_smooth.item(),
        }
        
        return total_loss
```

### 🎓 사용 예제

```python
from src.models import UNet

# 모델 생성
model = UNet(n_channels=16, n_classes=1)

# 손실 함수 생성
wavelengths = [5.0, 5.5, 6.05, 6.655]
loss_fn = PSI_PhysicsLoss(wavelengths, num_buckets=4)

# 더미 데이터
buckets = torch.randn(2, 16, 128, 128)  # (batch, channels, H, W)

# Forward pass
predicted_height = model(buckets)
loss = loss_fn(predicted_height, buckets)

print(f"총 손실: {loss.item():.6f}")
print(f"메트릭: {loss_fn.metrics}")
```

---

## 전체 워크플로우

### 🔄 학습 과정

```
┌──────────────────┐
│ 입력: Bucket 이미지│
│  (16채널)         │
└────────┬─────────┘
         ↓
┌────────────────────┐
│  신경망 (UNet)      │
│  bucket → height   │
└────────┬───────────┘
         ↓
┌───────────────────┐
│ 예측: Height 맵    │
│  (1채널)          │
└────────┬──────────┘
         ↓
┌──────────────────────┐
│ 물리 모델 (손실 함수 내)│
│ height → phase       │
│ phase → bucket 재생성 │
└────────┬─────────────┘
         ↓
┌─────────────────────┐
│ 비교: Predicted vs  │
│       Real Buckets  │
└────────┬────────────┘
         ↓
┌────────────────┐
│ 역전파 & 업데이트│
└────────────────┘
```

### 📊 추론 과정

```
┌──────────────────┐
│ 입력: Bucket 이미지│
└────────┬─────────┘
         ↓
┌────────────────┐
│ 신경망 (학습됨) │
└────────┬───────┘
         ↓
┌───────────────┐
│ 출력: Height 맵│
└───────────────┘
```

**추론 시에는 물리 모델 불필요!**

---

## 실습 예제

### 🧪 실습 1: 합성 데이터 생성

```python
# 1. 데이터 생성
from src.data_generator import generate_synthetic_data

height_gt, buckets = generate_synthetic_data(
    shape=(256, 256),
    wavelengths=[5.0, 5.5, 6.05, 6.655],
    num_buckets=4,
    save_path="psi_data"
)

print(f"높이 맵 형태: {height_gt.shape}")
print(f"Bucket 형태: {buckets.shape}")

# 2. 시각화
visualize_psi_data(height_gt, buckets, wavelength_idx=0)
```

### 🧪 실습 2: 물리 모델 검증

```python
# 높이 → Bucket → 높이 복원 테스트
import torch

# 간단한 높이 맵
h_test = torch.tensor([[1.0, 2.0], [3.0, 4.0]])
wavelength = 5.0

# Forward: 높이 → 위상 → Bucket
phase = (4 * np.pi / wavelength) * h_test
deltas = torch.tensor([0, np.pi/2, np.pi, 3*np.pi/2])
buckets_test = []
for delta in deltas:
    I = 128 + 100 * torch.cos(phase + delta)
    buckets_test.append(I)
buckets_test = torch.stack(buckets_test, dim=0)

print(f"생성된 Buckets:\n{buckets_test}")

# Backward: Bucket → 위상 복원
phase_recovered = torch.atan2(
    buckets_test[3] - buckets_test[1],
    buckets_test[0] - buckets_test[2]
)

# 위상 → 높이 복원
h_recovered = (wavelength / (4 * np.pi)) * phase_recovered

print(f"\n원래 높이:\n{h_test}")
print(f"복원 높이:\n{h_recovered}")
print(f"오차: {torch.abs(h_test - h_recovered).max().item():.6f}")
```

### 🧪 실습 3: PINN 훈련 (간단 버전)

```python
from src.models import UNet
from src.loss import UNetPhysicsLoss
import torch.optim as optim

# 설정
wavelengths = [5.0, 5.5, 6.05, 6.655]
device = torch.device('cuda' if torch.cuda.is_available() else 'cpu')

# 모델 및 손실
model = UNet(n_channels=16, n_classes=1).to(device)
loss_fn = UNetPhysicsLoss(wavelengths, num_buckets=4)
optimizer = optim.Adam(model.parameters(), lr=1e-3)

# 훈련 데이터 (실제로는 DataLoader 사용)
buckets_tensor = torch.from_numpy(buckets.reshape(1, 16, 256, 256)).float().to(device)

# 훈련 루프
num_epochs = 100
for epoch in range(num_epochs):
    optimizer.zero_grad()
    
    # Forward
    predicted_height = model(buckets_tensor)
    loss = loss_fn(predicted_height, buckets_tensor)
    
    # Backward
    loss.backward()
    optimizer.step()
    
    if (epoch + 1) % 10 == 0:
        print(f"Epoch {epoch+1}/{num_epochs}, Loss: {loss.item():.6f}")

print("훈련 완료!")
```

---

## 📚 추가 자료

### 학술 자료
- **Creath, K. (1988).** "Phase-measurement interferometry techniques." *Progress in Optics*, 26, 349-393.
- **Bruning, J. H., et al. (1974).** "Digital wavefront measuring interferometer for testing optical surfaces and lenses." *Applied Optics*, 13(11), 2693-2703.

### 프로젝트 관련
- `src/data_generator.py`: 데이터 생성 구현
- `src/loss.py`: 물리 기반 손실 함수
- `examples/solve_reconstruction_from_buckets.py`: 전체 파이프라인

---

## 🎯 체크포인트

다음 항목을 모두 이해했으면 완료입니다!

- [ ] 간섭계의 원리 이해
- [ ] 위상-높이 관계식 이해
- [ ] 4-step PSI 알고리즘 구현 가능
- [ ] Bucket 이미지 생성 원리 이해
- [ ] 다중 파장의 필요성 이해
- [ ] Physics-Informed Loss 설계 원리 이해
- [ ] 전체 워크플로우 파악

---

## 🆘 자주 묻는 질문

### Q1: 왜 4-step인가요? 3-step이나 5-step은 안 되나요?

**A:** 가능합니다! 하지만 4-step이 가장 일반적입니다.
- 3-step: 최소 요구사항 (비용 절감)
- 4-step: 균형잡힌 선택 (정확도 vs 속도)
- 5-step 이상: 더 높은 정확도 (노이즈 감소)

### Q2: 위상 wrapping 문제란?

**A:** `atan2`는 `-π ~ π` 범위만 반환하므로, 높이가 `λ/4`를 초과하면 위상이 반복됩니다.

**해결책:** 다중 파장 기법으로 unwrapping!

### Q3: PINN 없이 전통적 방법으로도 복원 가능한가요?

**A:** 네! 4-step 공식으로 직접 계산 가능합니다. 하지만 PINN의 장점:
- 노이즈에 강건
- 물리 제약 자동 만족
- 부족한 데이터에도 작동

---

## 🎉 축하합니다!

위상 천이 간섭법을 완전히 마스터했습니다!

이제 실제 프로젝트에서 높이 복원 문제를 다룰 준비가 되었습니다.

**다음 단계:**

👉 `examples/solve_reconstruction_from_buckets.py` 실행해보기  
👉 실제 데이터로 PINN 훈련하기

---

*마지막 업데이트: 2025년 10월 25일*
*작성자: Scaled-cPIKAN 개발팀*
