# ìœ„ìƒ ì²œì´ ê°„ì„­ë²• (Phase Shifting Interferometry) ì™„ì „ ê°€ì´ë“œ ğŸŒŠ

> **ë‚œì´ë„:** ì¤‘ê¸‰  
> **ì†Œìš” ì‹œê°„:** 90ë¶„  
> **ì‚¬ì „ ì§€ì‹:** íŒŒë™ ê¸°ì´ˆ, ì‚¼ê°í•¨ìˆ˜, Python

---

## ğŸ¯ í•™ìŠµ ëª©í‘œ

ì´ ê°€ì´ë“œë¥¼ ë§ˆì¹˜ë©´ ë‹¤ìŒì„ í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤:

- âœ… ìœ„ìƒ ì²œì´ ê°„ì„­ë²•(PSI)ì˜ ë¬¼ë¦¬ì  ì›ë¦¬ ì´í•´í•˜ê¸°
- âœ… 4-step PSI ì•Œê³ ë¦¬ì¦˜ êµ¬í˜„í•˜ê¸°
- âœ… ë‹¤ì¤‘ íŒŒì¥ ê¸°ë²•ìœ¼ë¡œ ì¸¡ì • ë²”ìœ„ í™•ì¥í•˜ê¸°
- âœ… Bucket ì´ë¯¸ì§€ì—ì„œ ë†’ì´ ë³µì›í•˜ëŠ” ë°©ë²• ì´í•´í•˜ê¸°
- âœ… PINNì—ì„œ ë¬¼ë¦¬ ëª¨ë¸ì„ ì†ì‹¤ í•¨ìˆ˜ì— í†µí•©í•˜ëŠ” ë°©ë²• ìµíˆê¸°

---

## ğŸ“‹ ëª©ì°¨

1. [ê°„ì„­ê³„ë€ ë¬´ì—‡ì¸ê°€?](#ê°„ì„­ê³„ë€-ë¬´ì—‡ì¸ê°€)
2. [ìœ„ìƒê³¼ ë†’ì´ì˜ ê´€ê³„](#ìœ„ìƒê³¼-ë†’ì´ì˜-ê´€ê³„)
3. [4-Step ìœ„ìƒ ì²œì´ ê°„ì„­ë²•](#4-step-ìœ„ìƒ-ì²œì´-ê°„ì„­ë²•)
4. [Bucket ì´ë¯¸ì§€ ìƒì„± ì›ë¦¬](#bucket-ì´ë¯¸ì§€-ìƒì„±-ì›ë¦¬)
5. [ë‹¤ì¤‘ íŒŒì¥ ê¸°ë²•](#ë‹¤ì¤‘-íŒŒì¥-ê¸°ë²•)
6. [ë°ì´í„° ìƒì„± êµ¬í˜„](#ë°ì´í„°-ìƒì„±-êµ¬í˜„)
7. [Physics-Informed Loss ì„¤ê³„](#physics-informed-loss-ì„¤ê³„)
8. [ì „ì²´ ì›Œí¬í”Œë¡œìš°](#ì „ì²´-ì›Œí¬í”Œë¡œìš°)
9. [ì‹¤ìŠµ ì˜ˆì œ](#ì‹¤ìŠµ-ì˜ˆì œ)

---

## ê°„ì„­ê³„ë€ ë¬´ì—‡ì¸ê°€?

### ğŸŒŠ íŒŒë™ì˜ ê°„ì„­ í˜„ìƒ

ë‘ ê°œì˜ íŒŒë™ì´ ë§Œë‚˜ë©´ **ê°„ì„­(interference)** í˜„ìƒì´ ë°œìƒí•©ë‹ˆë‹¤.

```
íŒŒë™ 1: ~~~~~~~~~~~
íŒŒë™ 2:    ~~~~~~~~~~~
         â†“
ê²°ê³¼:   âˆ¿âˆ¿âˆ¿âˆ¿âˆ¿âˆ¿âˆ¿âˆ¿âˆ¿âˆ¿âˆ¿
      (ë³´ê°• ê°„ì„­)

íŒŒë™ 1: ~~~~~~~~~~~
íŒŒë™ 2:    âˆªâˆªâˆªâˆªâˆªâˆªâˆªâˆªâˆªâˆª
         â†“
ê²°ê³¼:   ___________
      (ìƒì‡„ ê°„ì„­)
```

### ğŸ’¡ ê°„ì„­ê³„ì˜ ì›ë¦¬

**ë ˆì´ì € ê°„ì„­ê³„**ëŠ” ì´ ì›ë¦¬ë¥¼ ì´ìš©í•´ ê·¹ë¯¸ì„¸í•œ ë†’ì´ ë³€í™”ë¥¼ ì¸¡ì •í•©ë‹ˆë‹¤!

```
        ë ˆì´ì €
          â†“
      â”Œâ”€â”€â”€â”´â”€â”€â”€â”
      â”‚ ë¹”ë¶„í• ê¸°â”‚
      â””â”€â”¬â”€â”€â”€â”¬â”€â”˜
        â”‚   â”‚
     ê¸°ì¤€ë©´ ì¸¡ì •ë©´
        â”‚   â”‚ (ë†’ì´ h)
        â”‚   â”‚
      ë°˜ì‚¬ê´‘ ë°˜ì‚¬ê´‘
        â”‚   â”‚
        â””â”€â”¬â”€â”˜
       ê²€ì¶œê¸°
        â†“
    ê°„ì„­ íŒ¨í„´
```

**í•µì‹¬ ì•„ì´ë””ì–´:**
- ì¸¡ì •ë©´ì˜ ë†’ì´ê°€ ë³€í•˜ë©´ â†’ ë¹›ì˜ ê²½ë¡œ ê¸¸ì´ê°€ ë³€í•¨
- ê²½ë¡œ ê¸¸ì´ ì°¨ì´ â†’ ìœ„ìƒ ì°¨ì´ ë°œìƒ
- ìœ„ìƒ ì°¨ì´ â†’ ê°„ì„­ íŒ¨í„´ì˜ ë°ê¸° ë³€í™”

---

## ìœ„ìƒê³¼ ë†’ì´ì˜ ê´€ê³„

### ğŸ“ ìˆ˜í•™ì  ê´€ê³„ì‹

í‘œë©´ ë†’ì´ `h`ì™€ ìœ„ìƒ `Ï†` ì‚¬ì´ì˜ ê´€ê³„:

```
Ï† = (4Ï€/Î») Ã— h
```

ì—¬ê¸°ì„œ:
- `Ï†`: ìœ„ìƒ (ë¼ë””ì•ˆ)
- `Î»`: ë ˆì´ì € íŒŒì¥ (ë§ˆì´í¬ë¡œë¯¸í„°)
- `h`: í‘œë©´ ë†’ì´ (ë§ˆì´í¬ë¡œë¯¸í„°)
- `4Ï€`: ì™•ë³µ ê²½ë¡œ (2Ã—2Ï€)

### ğŸ”„ ì—­ì‚° ê³µì‹

ë†’ì´ë¥¼ ê³„ì‚°í•˜ë ¤ë©´:

```
h = (Î»/(4Ï€)) Ã— Ï†
```

### ğŸ’¡ ì‹¤ì œ ì˜ˆì‹œ

**íŒŒì¥ Î» = 632.8 nm (He-Ne ë ˆì´ì €)**
```
ë†’ì´ h = 100 nmì¼ ë•Œ
Ï† = (4Ï€ / 632.8nm) Ã— 100nm
  = 1.983 ë¼ë””ì•ˆ
  â‰ˆ 113.6Â°
```

### ğŸ¨ ê°„ì„­ ê°•ë„ ê³µì‹

ì¸¡ì •ë˜ëŠ” ë¹›ì˜ ê°•ë„:

```
I(Ï†) = A + B Ã— cos(Ï†)
```

ì—¬ê¸°ì„œ:
- `A`: ë°°ê²½ ê°•ë„ (DC ì„±ë¶„)
- `B`: ê°„ì„­ ì§„í­ (AC ì„±ë¶„)
- `Ï†`: ìœ„ìƒ

**ê·¸ë˜í”„:**
```
I
â”‚     â•±ï¼¼      â•±ï¼¼
â”‚    â•±  ï¼¼    â•±  ï¼¼
A+B â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
â”‚   â•±    ï¼¼  â•±    ï¼¼
A  â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ (í‰ê· )
â”‚  â•±      ï¼¼â•±      ï¼¼
A-B â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€> Ï†
    0   Ï€   2Ï€  3Ï€
```

---

## 4-Step ìœ„ìƒ ì²œì´ ê°„ì„­ë²•

### ğŸ¯ ë¬¸ì œì 

**ë‹¨ì¼ ì¸¡ì •ì˜ í•œê³„:**
- `I = A + BÃ—cos(Ï†)` ì—ì„œ `A`, `B`, `Ï†` ëª¨ë‘ ë¯¸ì§€ìˆ˜!
- ë°©ì •ì‹ 1ê°œ, ë¯¸ì§€ìˆ˜ 3ê°œ â†’ í•´ê°€ ë¬´í•œê°œ

**í•´ê²°ì±…: ìœ„ìƒì„ ë³€í™”ì‹œí‚¤ë©° ì—¬ëŸ¬ ë²ˆ ì¸¡ì •!**

### ğŸ“· 4-Step PSI ì•Œê³ ë¦¬ì¦˜

4ë²ˆ ì¸¡ì •í•˜ë©° **ìœ„ìƒ ì²œì´** `Î´`ë¥¼ ì¶”ê°€:

```
Iâ‚€ = A + B Ã— cos(Ï† + 0Â°)     [Î´ = 0Â°]
Iâ‚ = A + B Ã— cos(Ï† + 90Â°)    [Î´ = Ï€/2]
Iâ‚‚ = A + B Ã— cos(Ï† + 180Â°)   [Î´ = Ï€]
Iâ‚ƒ = A + B Ã— cos(Ï† + 270Â°)   [Î´ = 3Ï€/2]
```

### ğŸ§® ìœ„ìƒ ë³µì› ê³µì‹

4ê°œì˜ ì¸¡ì •ê°’ìœ¼ë¡œë¶€í„° ìœ„ìƒ ê³„ì‚°:

```
Ï† = atan2(Iâ‚ƒ - Iâ‚, Iâ‚€ - Iâ‚‚)
```

**ìœ ë„ ê³¼ì •:**
```
Iâ‚€ - Iâ‚‚ = 2B Ã— cos(Ï†)
Iâ‚ƒ - Iâ‚ = 2B Ã— sin(Ï†)

tan(Ï†) = (Iâ‚ƒ - Iâ‚)/(Iâ‚€ - Iâ‚‚)
Ï† = atan2(Iâ‚ƒ - Iâ‚, Iâ‚€ - Iâ‚‚)
```

### ğŸ’» Python êµ¬í˜„

```python
import numpy as np

def phase_from_4step(I0, I1, I2, I3):
    """
    4-step PSIë¡œ ìœ„ìƒ ë³µì›
    
    Args:
        I0, I1, I2, I3: 4ê°œì˜ bucket ì´ë¯¸ì§€ (numpy arrays)
    
    Returns:
        phase: ë³µì›ëœ ìœ„ìƒ (ë¼ë””ì•ˆ)
    """
    numerator = I3 - I1
    denominator = I0 - I2
    phase = np.arctan2(numerator, denominator)
    return phase

# ì˜ˆì‹œ
I0 = 128 + 100 * np.cos(1.5)
I1 = 128 + 100 * np.cos(1.5 + np.pi/2)
I2 = 128 + 100 * np.cos(1.5 + np.pi)
I3 = 128 + 100 * np.cos(1.5 + 3*np.pi/2)

phi_recovered = phase_from_4step(I0, I1, I2, I3)
print(f"ì›ë˜ ìœ„ìƒ: 1.5 rad")
print(f"ë³µì› ìœ„ìƒ: {phi_recovered:.4f} rad")
```

---

## Bucket ì´ë¯¸ì§€ ìƒì„± ì›ë¦¬

### ğŸª£ "Bucket"ì´ë€?

**Bucket ì´ë¯¸ì§€**: ê° ìœ„ìƒ ì²œì´ ë‹¨ê³„ì—ì„œ ì´¬ì˜ëœ ê°„ì„­ íŒ¨í„´ ì´ë¯¸ì§€

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ Bucket 0    â”‚  â”‚ Bucket 1    â”‚  â”‚ Bucket 2    â”‚  â”‚ Bucket 3    â”‚
â”‚ (Î´ = 0Â°)    â”‚  â”‚ (Î´ = 90Â°)   â”‚  â”‚ (Î´ = 180Â°)  â”‚  â”‚ (Î´ = 270Â°)  â”‚
â”‚  â—‹ â— â—‹ â—    â”‚  â”‚  â— â—‹ â— â—‹    â”‚  â”‚  â—‹ â— â—‹ â—    â”‚  â”‚  â— â—‹ â— â—‹    â”‚
â”‚  â— â—‹ â— â—‹    â”‚  â”‚  â—‹ â— â—‹ â—    â”‚  â”‚  â— â—‹ â— â—‹    â”‚  â”‚  â—‹ â— â—‹ â—    â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

### ğŸ”¢ ìˆ˜ì¹˜ì  ìƒì„±

**ë‹¨ì¼ í”½ì…€ì—ì„œ:**
```python
A = 128  # ë°°ê²½ ê°•ë„
B = 100  # ê°„ì„­ ì§„í­
h = 0.5  # ë†’ì´ (Î¼m)
Î» = 5.0  # íŒŒì¥ (Î¼m)

# ìœ„ìƒ ê³„ì‚°
Ï† = (4 * np.pi / Î») * h

# 4ê°œì˜ ìœ„ìƒ ì²œì´
deltas = [0, np.pi/2, np.pi, 3*np.pi/2]

# Bucket ê°’ ìƒì„±
buckets = [A + B * np.cos(Ï† + Î´) for Î´ in deltas]
print(f"Bucket ê°’ë“¤: {buckets}")
```

### ğŸ–¼ï¸ ì´ë¯¸ì§€ ì „ì²´ ìƒì„±

```python
def generate_buckets(height_map, wavelength, A=128, B=100):
    """
    ë†’ì´ ë§µìœ¼ë¡œë¶€í„° 4ê°œì˜ bucket ì´ë¯¸ì§€ ìƒì„±
    
    Args:
        height_map: (H, W) ë†’ì´ ë§µ (Î¼m)
        wavelength: ë ˆì´ì € íŒŒì¥ (Î¼m)
        A: ë°°ê²½ ê°•ë„
        B: ê°„ì„­ ì§„í­
    
    Returns:
        buckets: (4, H, W) bucket ì´ë¯¸ì§€ ë°°ì—´
    """
    # ìœ„ìƒ ê³„ì‚°
    phase = (4 * np.pi / wavelength) * height_map
    
    # 4ê°œì˜ ìœ„ìƒ ì²œì´
    deltas = np.array([0, np.pi/2, np.pi, 3*np.pi/2])
    
    # Bucket ì´ë¯¸ì§€ ìƒì„±
    buckets = []
    for delta in deltas:
        intensity = A + B * np.cos(phase + delta)
        buckets.append(intensity)
    
    return np.array(buckets)

# ì˜ˆì‹œ: ê°„ë‹¨í•œ ê²½ì‚¬ë©´
H, W = 128, 128
x = np.linspace(0, 10, W)
y = np.linspace(0, 10, H)
X, Y = np.meshgrid(x, y)
height_map = 0.5 * X  # ê²½ì‚¬ë©´ (0 ~ 5 Î¼m)

buckets = generate_buckets(height_map, wavelength=5.0)
print(f"ìƒì„±ëœ bucket í˜•íƒœ: {buckets.shape}")
```

---

## ë‹¤ì¤‘ íŒŒì¥ ê¸°ë²•

### ğŸŒˆ ì™œ ì—¬ëŸ¬ íŒŒì¥ì´ í•„ìš”í•œê°€?

**ë‹¨ì¼ íŒŒì¥ì˜ ë¬¸ì œì :**
- `atan2`ëŠ” `-Ï€ ~ Ï€` ë²”ìœ„ë§Œ ë°˜í™˜ (wrapping ë°œìƒ)
- ì¸¡ì • ê°€ëŠ¥í•œ ìµœëŒ€ ë†’ì´ ì œí•œ: `h_max = Î»/4`

**ì˜ˆì‹œ:**
```
Î» = 5.0 Î¼m â†’ h_max = 1.25 Î¼m
Î» = 0.632 Î¼m â†’ h_max = 0.158 Î¼m
```

### ğŸ“ ë‹¤ì¤‘ íŒŒì¥ í•´ê²°ì±…

**4ê°œì˜ ì„œë¡œ ë‹¤ë¥¸ íŒŒì¥ ì‚¬ìš©:**
```
Î»â‚ = 5.000 Î¼m  (ì ì™¸ì„ )
Î»â‚‚ = 5.500 Î¼m
Î»â‚ƒ = 6.050 Î¼m
Î»â‚„ = 6.655 Î¼m
```

**ì›ë¦¬:**
- ê° íŒŒì¥ë§ˆë‹¤ wrapping ì£¼ê¸°ê°€ ë‹¤ë¦„
- ì—¬ëŸ¬ ì¸¡ì •ì„ ê²°í•©í•˜ì—¬ **ìœ„ìƒ ì–¸ë˜í•‘ (unwrapping)** ìˆ˜í–‰
- ì¸¡ì • ë²”ìœ„ ëŒ€í­ í™•ì¥

### ğŸ”§ í•©ì„± íŒŒì¥

ë‘ íŒŒì¥ì˜ ì¡°í•©ìœ¼ë¡œ ë” ê¸´ **í•©ì„± íŒŒì¥** ìƒì„±:

```
Î›â‚â‚‚ = (Î»â‚ Ã— Î»â‚‚) / |Î»â‚ - Î»â‚‚|
```

**ì˜ˆì‹œ:**
```
Î»â‚ = 5.0 Î¼m, Î»â‚‚ = 5.5 Î¼m
Î›â‚â‚‚ = (5.0 Ã— 5.5) / 0.5 = 55 Î¼m

ì¸¡ì • ë²”ìœ„: 55/4 = 13.75 Î¼m (ë‹¨ì¼ íŒŒì¥ì˜ 11ë°°!)
```

### ğŸ’» ë‹¤ì¤‘ íŒŒì¥ ë°ì´í„° ìƒì„±

```python
def generate_multiwavelength_buckets(height_map, wavelengths, num_buckets=4):
    """
    ë‹¤ì¤‘ íŒŒì¥ bucket ì´ë¯¸ì§€ ìƒì„±
    
    Args:
        height_map: (H, W) ë†’ì´ ë§µ
        wavelengths: íŒŒì¥ ë¦¬ìŠ¤íŠ¸ [Î»â‚, Î»â‚‚, Î»â‚ƒ, Î»â‚„]
        num_buckets: ê° íŒŒì¥ë‹¹ bucket ìˆ˜
    
    Returns:
        all_buckets: (num_wavelengths * num_buckets, H, W)
    """
    all_buckets = []
    
    for wavelength in wavelengths:
        buckets = generate_buckets(height_map, wavelength)
        all_buckets.append(buckets)
    
    # (4 wavelengths, 4 buckets, H, W) â†’ (16, H, W)
    all_buckets = np.concatenate(all_buckets, axis=0)
    
    return all_buckets

# ì˜ˆì‹œ
wavelengths = [5.0, 5.5, 6.05, 6.655]
buckets_multi = generate_multiwavelength_buckets(height_map, wavelengths)
print(f"ë‹¤ì¤‘ íŒŒì¥ buckets í˜•íƒœ: {buckets_multi.shape}")  # (16, 128, 128)
```

---

## ë°ì´í„° ìƒì„± êµ¬í˜„

### ğŸ“¦ í”„ë¡œì íŠ¸ì˜ ë°ì´í„° ìƒì„±ê¸°

`src/data_generator.py`ì˜ êµ¬í˜„:

```python
import numpy as np

DEFAULT_WAVELENGTHS = [5.0, 5.5, 6.05, 6.655]  # Î¼m

def generate_synthetic_data(
    shape=(128, 128),
    wavelengths=None,
    num_buckets=4,
    save_path="reconstruction_data",
    output_format='bmp'
):
    """
    í•©ì„± ë°ì´í„° ìƒì„± (ë†’ì´ ë§µ + bucket ì´ë¯¸ì§€)
    
    Args:
        shape: ì´ë¯¸ì§€ í¬ê¸° (H, W)
        wavelengths: ë ˆì´ì € íŒŒì¥ ë¦¬ìŠ¤íŠ¸
        num_buckets: ê° ë ˆì´ì €ë‹¹ bucket ìˆ˜
        save_path: ì €ì¥ ê²½ë¡œ
        output_format: ì¶œë ¥ í˜•ì‹ ('bmp', 'png', 'npy')
    
    Returns:
        ground_truth_height: (H, W) ë†’ì´ ë§µ
        bucket_images: (num_lasers, num_buckets, H, W)
    """
    if wavelengths is None:
        wavelengths = DEFAULT_WAVELENGTHS
    
    height, width = shape
    num_lasers = len(wavelengths)
    
    # --- 1. Ground Truth ë†’ì´ ë§µ ìƒì„± ---
    x = np.linspace(-1, 1, width)
    y = np.linspace(-1, 1, height)
    xx, yy = np.meshgrid(x, y)
    
    # ë³µì¡í•œ í‘œë©´ ìƒì„± (ê°€ìš°ì‹œì•ˆ í”¼í¬ + í‰ë©´ + ì›ë¿”)
    peak = 15.0 * np.exp(-((xx - 0.2)**2 + (yy + 0.3)**2) / 0.2)
    plane = 5.0 * xx + 2.5 * yy
    cone = 10.0 * np.sqrt((xx + 0.5)**2 + (yy - 0.4)**2)
    ground_truth_height = peak + plane + cone
    
    print(f"ìƒì„±ëœ ë†’ì´ ë²”ìœ„: [{ground_truth_height.min():.2f}, {ground_truth_height.max():.2f}] Î¼m")
    
    # --- 2. ê° ë ˆì´ì €ì— ëŒ€í•œ Bucket ì´ë¯¸ì§€ ìƒì„± ---
    all_bucket_images = []
    deltas = np.linspace(0, 2 * np.pi, num_buckets, endpoint=False)
    
    A, B = 128, 100  # ê°•ë„ íŒŒë¼ë¯¸í„°
    
    for i, wavelength in enumerate(wavelengths):
        # ìœ„ìƒ ê³„ì‚°
        phase = (4 * np.pi * ground_truth_height) / wavelength
        
        # Bucket ìƒì„±
        buckets = [A + B * np.cos(phase + delta) for delta in deltas]
        laser_buckets = np.stack(buckets, axis=0)
        all_bucket_images.append(laser_buckets)
        
        print(f"ë ˆì´ì € {i+1} (Î»={wavelength} Î¼m): {num_buckets}ê°œ bucket ìƒì„±")
    
    # (num_lasers, num_buckets, H, W)
    bucket_images_np = np.array(all_bucket_images)
    
    return ground_truth_height, bucket_images_np
```

### ğŸ¨ ì‹œê°í™” í•¨ìˆ˜

```python
import matplotlib.pyplot as plt

def visualize_psi_data(height_map, buckets, wavelength_idx=0):
    """PSI ë°ì´í„° ì‹œê°í™”"""
    fig, axes = plt.subplots(2, 3, figsize=(15, 10))
    
    # ë†’ì´ ë§µ
    im0 = axes[0, 0].imshow(height_map, cmap='viridis')
    axes[0, 0].set_title('Ground Truth Height Map')
    plt.colorbar(im0, ax=axes[0, 0])
    
    # 4ê°œì˜ bucket ì´ë¯¸ì§€
    buckets_laser = buckets[wavelength_idx]
    for i in range(4):
        ax = axes[i//2, i%2 + 1] if i < 2 else axes[(i-2)//2 + 1, (i-2)%2]
        im = ax.imshow(buckets_laser[i], cmap='gray')
        ax.set_title(f'Bucket {i} (Î´={i*90}Â°)')
        plt.colorbar(im, ax=ax)
    
    # ìœ„ìƒ ë§µ
    phase = np.arctan2(
        buckets_laser[3] - buckets_laser[1],
        buckets_laser[0] - buckets_laser[2]
    )
    im5 = axes[1, 2].imshow(phase, cmap='hsv')
    axes[1, 2].set_title('Recovered Phase (wrapped)')
    plt.colorbar(im5, ax=axes[1, 2])
    
    plt.tight_layout()
    plt.show()
```

---

## Physics-Informed Loss ì„¤ê³„

### ğŸ¯ í•µì‹¬ ì•„ì´ë””ì–´

**ìˆœë°©í–¥ ë¬¼ë¦¬ ëª¨ë¸ì„ ì†ì‹¤ í•¨ìˆ˜ì— í†µí•©!**

```
í›ˆë ¨ ë£¨í”„:
  1. ëª¨ë¸ì´ ë†’ì´ ì˜ˆì¸¡: h_pred = Model(buckets)
  2. ë¬¼ë¦¬ ëª¨ë¸ë¡œ bucket ì¬ìƒì„±: buckets_pred = Physics(h_pred)
  3. ì‹¤ì œ bucketê³¼ ë¹„êµ: Loss = MSE(buckets_pred, buckets_real)
  4. ì—­ì „íŒŒë¡œ ëª¨ë¸ ì—…ë°ì´íŠ¸
```

### ğŸ“ ìˆ˜í•™ì  ì •ì˜

**ë°ì´í„° ì¼ê´€ì„± ì†ì‹¤:**

```
L_data = (1/N) Î£áµ¢ Î£â±¼ |I_pred(i,j) - I_real(i,j)|Â²
```

ì—¬ê¸°ì„œ:
- `i`: ë ˆì´ì € ì¸ë±ìŠ¤ (1~4)
- `j`: bucket ì¸ë±ìŠ¤ (1~4)
- `I_pred`: ì˜ˆì¸¡ ë†’ì´ë¡œë¶€í„° ì¬ìƒì„±ëœ bucket
- `I_real`: ì‹¤ì œ ì¸¡ì • bucket

**ì „ì²´ ì†ì‹¤:**

```
L_total = L_data + Î»_smooth Ã— L_smooth
```

`L_smooth`: í‰í™œë„ ì •ê·œí™” (Laplacian penalty)

### ğŸ’» PyTorch êµ¬í˜„

```python
import torch
import torch.nn as nn
import numpy as np

class PSI_PhysicsLoss(nn.Module):
    """
    ìœ„ìƒ ì²œì´ ê°„ì„­ë²• ê¸°ë°˜ ë¬¼ë¦¬ ì†ì‹¤ í•¨ìˆ˜
    """
    def __init__(self, wavelengths, num_buckets=4, smoothness_weight=1e-4):
        super().__init__()
        self.wavelengths = torch.tensor(wavelengths, dtype=torch.float32).view(-1, 1, 1, 1)
        
        # ìœ„ìƒ ì²œì´ ê°ë„
        deltas = torch.arange(num_buckets, dtype=torch.float32) * (2 * np.pi / num_buckets)
        self.deltas = deltas.view(1, num_buckets, 1, 1)
        
        self.smoothness_weight = smoothness_weight
        self.mse_loss = nn.MSELoss()
        
        # Laplacian ì»¤ë„
        laplacian_kernel = torch.tensor([[0, 1, 0], [1, -4, 1], [0, 1, 0]], dtype=torch.float32)
        self.laplacian_kernel = laplacian_kernel.view(1, 1, 3, 3)
    
    def forward(self, predicted_height, input_buckets):
        """
        ì†ì‹¤ ê³„ì‚°
        
        Args:
            predicted_height: (N, 1, H, W) ì˜ˆì¸¡ëœ ë†’ì´ ë§µ
            input_buckets: (N, 16, H, W) ì‹¤ì œ bucket ì´ë¯¸ì§€
        
        Returns:
            total_loss: ì´ ì†ì‹¤
        """
        device = predicted_height.device
        self.wavelengths = self.wavelengths.to(device)
        self.deltas = self.deltas.to(device)
        self.laplacian_kernel = self.laplacian_kernel.to(device)
        
        # --- 1. ë°ì´í„° ì¼ê´€ì„± ì†ì‹¤ ---
        # ì˜ˆì¸¡ ë†’ì´ â†’ ìœ„ìƒ â†’ bucket ì¬ìƒì„±
        height_expanded = predicted_height.unsqueeze(1)  # (N, 1, 1, H, W)
        
        # ìœ„ìƒ ê³„ì‚°: Ï† = (4Ï€/Î») Ã— h
        phase = (4 * np.pi / self.wavelengths) * height_expanded  # (N, num_lasers, 1, H, W)
        
        # ìœ„ìƒ ì²œì´ ì¶”ê°€
        phase_with_shifts = phase + self.deltas  # (N, num_lasers, num_buckets, H, W)
        
        # Bucket ì¬ìƒì„±: I = A + BÃ—cos(Ï† + Î´)
        A, B = 128, 100
        predicted_buckets = A + B * torch.cos(phase_with_shifts)
        
        # í˜•íƒœ ë³€í™˜ (N, num_lasers, num_buckets, H, W) â†’ (N, 16, H, W)
        predicted_buckets = predicted_buckets.view_as(input_buckets)
        
        # MSE ì†ì‹¤
        loss_data = self.mse_loss(predicted_buckets, input_buckets)
        
        # --- 2. í‰í™œë„ ì •ê·œí™” ---
        laplacian = torch.nn.functional.conv2d(predicted_height, self.laplacian_kernel, padding=1)
        loss_smooth = self.mse_loss(laplacian, torch.zeros_like(laplacian))
        
        # --- ì´ ì†ì‹¤ ---
        total_loss = loss_data + self.smoothness_weight * loss_smooth
        
        # ë©”íŠ¸ë¦­ ì €ì¥
        self.metrics = {
            "loss_total": total_loss.item(),
            "loss_data": loss_data.item(),
            "loss_smooth": loss_smooth.item(),
        }
        
        return total_loss
```

### ğŸ“ ì‚¬ìš© ì˜ˆì œ

```python
from src.models import UNet

# ëª¨ë¸ ìƒì„±
model = UNet(n_channels=16, n_classes=1)

# ì†ì‹¤ í•¨ìˆ˜ ìƒì„±
wavelengths = [5.0, 5.5, 6.05, 6.655]
loss_fn = PSI_PhysicsLoss(wavelengths, num_buckets=4)

# ë”ë¯¸ ë°ì´í„°
buckets = torch.randn(2, 16, 128, 128)  # (batch, channels, H, W)

# Forward pass
predicted_height = model(buckets)
loss = loss_fn(predicted_height, buckets)

print(f"ì´ ì†ì‹¤: {loss.item():.6f}")
print(f"ë©”íŠ¸ë¦­: {loss_fn.metrics}")
```

---

## ì „ì²´ ì›Œí¬í”Œë¡œìš°

### ğŸ”„ í•™ìŠµ ê³¼ì •

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ ì…ë ¥: Bucket ì´ë¯¸ì§€â”‚
â”‚  (16ì±„ë„)         â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
         â†“
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  ì‹ ê²½ë§ (UNet)      â”‚
â”‚  bucket â†’ height   â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
         â†“
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ ì˜ˆì¸¡: Height ë§µ    â”‚
â”‚  (1ì±„ë„)          â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
         â†“
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ ë¬¼ë¦¬ ëª¨ë¸ (ì†ì‹¤ í•¨ìˆ˜ ë‚´)â”‚
â”‚ height â†’ phase       â”‚
â”‚ phase â†’ bucket ì¬ìƒì„± â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
         â†“
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ ë¹„êµ: Predicted vs  â”‚
â”‚       Real Buckets  â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
         â†“
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ ì—­ì „íŒŒ & ì—…ë°ì´íŠ¸â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

### ğŸ“Š ì¶”ë¡  ê³¼ì •

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ ì…ë ¥: Bucket ì´ë¯¸ì§€â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
         â†“
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ ì‹ ê²½ë§ (í•™ìŠµë¨) â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”˜
         â†“
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ ì¶œë ¥: Height ë§µâ”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

**ì¶”ë¡  ì‹œì—ëŠ” ë¬¼ë¦¬ ëª¨ë¸ ë¶ˆí•„ìš”!**

---

## ì‹¤ìŠµ ì˜ˆì œ

### ğŸ§ª ì‹¤ìŠµ 1: í•©ì„± ë°ì´í„° ìƒì„±

```python
# 1. ë°ì´í„° ìƒì„±
from src.data_generator import generate_synthetic_data

height_gt, buckets = generate_synthetic_data(
    shape=(256, 256),
    wavelengths=[5.0, 5.5, 6.05, 6.655],
    num_buckets=4,
    save_path="psi_data"
)

print(f"ë†’ì´ ë§µ í˜•íƒœ: {height_gt.shape}")
print(f"Bucket í˜•íƒœ: {buckets.shape}")

# 2. ì‹œê°í™”
visualize_psi_data(height_gt, buckets, wavelength_idx=0)
```

### ğŸ§ª ì‹¤ìŠµ 2: ë¬¼ë¦¬ ëª¨ë¸ ê²€ì¦

```python
# ë†’ì´ â†’ Bucket â†’ ë†’ì´ ë³µì› í…ŒìŠ¤íŠ¸
import torch

# ê°„ë‹¨í•œ ë†’ì´ ë§µ
h_test = torch.tensor([[1.0, 2.0], [3.0, 4.0]])
wavelength = 5.0

# Forward: ë†’ì´ â†’ ìœ„ìƒ â†’ Bucket
phase = (4 * np.pi / wavelength) * h_test
deltas = torch.tensor([0, np.pi/2, np.pi, 3*np.pi/2])
buckets_test = []
for delta in deltas:
    I = 128 + 100 * torch.cos(phase + delta)
    buckets_test.append(I)
buckets_test = torch.stack(buckets_test, dim=0)

print(f"ìƒì„±ëœ Buckets:\n{buckets_test}")

# Backward: Bucket â†’ ìœ„ìƒ ë³µì›
phase_recovered = torch.atan2(
    buckets_test[3] - buckets_test[1],
    buckets_test[0] - buckets_test[2]
)

# ìœ„ìƒ â†’ ë†’ì´ ë³µì›
h_recovered = (wavelength / (4 * np.pi)) * phase_recovered

print(f"\nì›ë˜ ë†’ì´:\n{h_test}")
print(f"ë³µì› ë†’ì´:\n{h_recovered}")
print(f"ì˜¤ì°¨: {torch.abs(h_test - h_recovered).max().item():.6f}")
```

### ğŸ§ª ì‹¤ìŠµ 3: PINN í›ˆë ¨ (ê°„ë‹¨ ë²„ì „)

```python
from src.models import UNet
from src.loss import UNetPhysicsLoss
import torch.optim as optim

# ì„¤ì •
wavelengths = [5.0, 5.5, 6.05, 6.655]
device = torch.device('cuda' if torch.cuda.is_available() else 'cpu')

# ëª¨ë¸ ë° ì†ì‹¤
model = UNet(n_channels=16, n_classes=1).to(device)
loss_fn = UNetPhysicsLoss(wavelengths, num_buckets=4)
optimizer = optim.Adam(model.parameters(), lr=1e-3)

# í›ˆë ¨ ë°ì´í„° (ì‹¤ì œë¡œëŠ” DataLoader ì‚¬ìš©)
buckets_tensor = torch.from_numpy(buckets.reshape(1, 16, 256, 256)).float().to(device)

# í›ˆë ¨ ë£¨í”„
num_epochs = 100
for epoch in range(num_epochs):
    optimizer.zero_grad()
    
    # Forward
    predicted_height = model(buckets_tensor)
    loss = loss_fn(predicted_height, buckets_tensor)
    
    # Backward
    loss.backward()
    optimizer.step()
    
    if (epoch + 1) % 10 == 0:
        print(f"Epoch {epoch+1}/{num_epochs}, Loss: {loss.item():.6f}")

print("í›ˆë ¨ ì™„ë£Œ!")
```

---

## ğŸ“š ì¶”ê°€ ìë£Œ

### í•™ìˆ  ìë£Œ
- **Creath, K. (1988).** "Phase-measurement interferometry techniques." *Progress in Optics*, 26, 349-393.
- **Bruning, J. H., et al. (1974).** "Digital wavefront measuring interferometer for testing optical surfaces and lenses." *Applied Optics*, 13(11), 2693-2703.

### í”„ë¡œì íŠ¸ ê´€ë ¨
- `src/data_generator.py`: ë°ì´í„° ìƒì„± êµ¬í˜„
- `src/loss.py`: ë¬¼ë¦¬ ê¸°ë°˜ ì†ì‹¤ í•¨ìˆ˜
- `examples/solve_reconstruction_from_buckets.py`: ì „ì²´ íŒŒì´í”„ë¼ì¸

---

## ğŸ¯ ì²´í¬í¬ì¸íŠ¸

ë‹¤ìŒ í•­ëª©ì„ ëª¨ë‘ ì´í•´í–ˆìœ¼ë©´ ì™„ë£Œì…ë‹ˆë‹¤!

- [ ] ê°„ì„­ê³„ì˜ ì›ë¦¬ ì´í•´
- [ ] ìœ„ìƒ-ë†’ì´ ê´€ê³„ì‹ ì´í•´
- [ ] 4-step PSI ì•Œê³ ë¦¬ì¦˜ êµ¬í˜„ ê°€ëŠ¥
- [ ] Bucket ì´ë¯¸ì§€ ìƒì„± ì›ë¦¬ ì´í•´
- [ ] ë‹¤ì¤‘ íŒŒì¥ì˜ í•„ìš”ì„± ì´í•´
- [ ] Physics-Informed Loss ì„¤ê³„ ì›ë¦¬ ì´í•´
- [ ] ì „ì²´ ì›Œí¬í”Œë¡œìš° íŒŒì•…

---

## ğŸ†˜ ìì£¼ ë¬»ëŠ” ì§ˆë¬¸

### Q1: ì™œ 4-stepì¸ê°€ìš”? 3-stepì´ë‚˜ 5-stepì€ ì•ˆ ë˜ë‚˜ìš”?

**A:** ê°€ëŠ¥í•©ë‹ˆë‹¤! í•˜ì§€ë§Œ 4-stepì´ ê°€ì¥ ì¼ë°˜ì ì…ë‹ˆë‹¤.
- 3-step: ìµœì†Œ ìš”êµ¬ì‚¬í•­ (ë¹„ìš© ì ˆê°)
- 4-step: ê· í˜•ì¡íŒ ì„ íƒ (ì •í™•ë„ vs ì†ë„)
- 5-step ì´ìƒ: ë” ë†’ì€ ì •í™•ë„ (ë…¸ì´ì¦ˆ ê°ì†Œ)

### Q2: ìœ„ìƒ wrapping ë¬¸ì œë€?

**A:** `atan2`ëŠ” `-Ï€ ~ Ï€` ë²”ìœ„ë§Œ ë°˜í™˜í•˜ë¯€ë¡œ, ë†’ì´ê°€ `Î»/4`ë¥¼ ì´ˆê³¼í•˜ë©´ ìœ„ìƒì´ ë°˜ë³µë©ë‹ˆë‹¤.

**í•´ê²°ì±…:** ë‹¤ì¤‘ íŒŒì¥ ê¸°ë²•ìœ¼ë¡œ unwrapping!

### Q3: PINN ì—†ì´ ì „í†µì  ë°©ë²•ìœ¼ë¡œë„ ë³µì› ê°€ëŠ¥í•œê°€ìš”?

**A:** ë„¤! 4-step ê³µì‹ìœ¼ë¡œ ì§ì ‘ ê³„ì‚° ê°€ëŠ¥í•©ë‹ˆë‹¤. í•˜ì§€ë§Œ PINNì˜ ì¥ì :
- ë…¸ì´ì¦ˆì— ê°•ê±´
- ë¬¼ë¦¬ ì œì•½ ìë™ ë§Œì¡±
- ë¶€ì¡±í•œ ë°ì´í„°ì—ë„ ì‘ë™

---

## ğŸ‰ ì¶•í•˜í•©ë‹ˆë‹¤!

ìœ„ìƒ ì²œì´ ê°„ì„­ë²•ì„ ì™„ì „íˆ ë§ˆìŠ¤í„°í–ˆìŠµë‹ˆë‹¤!

ì´ì œ ì‹¤ì œ í”„ë¡œì íŠ¸ì—ì„œ ë†’ì´ ë³µì› ë¬¸ì œë¥¼ ë‹¤ë£° ì¤€ë¹„ê°€ ë˜ì—ˆìŠµë‹ˆë‹¤.

**ë‹¤ìŒ ë‹¨ê³„:**

ğŸ‘‰ `examples/solve_reconstruction_from_buckets.py` ì‹¤í–‰í•´ë³´ê¸°  
ğŸ‘‰ ì‹¤ì œ ë°ì´í„°ë¡œ PINN í›ˆë ¨í•˜ê¸°

---

*ë§ˆì§€ë§‰ ì—…ë°ì´íŠ¸: 2025ë…„ 10ì›” 25ì¼*
*ì‘ì„±ì: Scaled-cPIKAN ê°œë°œíŒ€*
