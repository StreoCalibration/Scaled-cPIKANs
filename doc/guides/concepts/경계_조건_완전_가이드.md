# 경계 조건 완전 가이드 🔲

> **주제:** Dirichlet, Neumann, Robin, Periodic 경계 조건의 모든 것  
> **난이도:** 중급  
> **소요 시간:** 1시간  
> **사전 지식:** PDE 기초, 미적분

---

## 🎯 학습 목표

이 가이드를 마치면:

- ✅ 경계 조건이 왜 필요한지 이해
- ✅ 4가지 경계 조건의 물리적 의미 파악
- ✅ 언제 어떤 경계 조건을 사용하는지 결정 가능
- ✅ PINN에서 각 경계 조건 구현
- ✅ 실제 예제로 차이 확인

---

## 📚 목차

1. [경계 조건이란?](#-part-1-경계-조건이란)
2. [왜 필요한가?](#-part-2-왜-필요한가)
3. [Dirichlet 경계 조건](#-part-3-dirichlet-경계-조건)
4. [Neumann 경계 조건](#-part-4-neumann-경계-조건)
5. [Robin 경계 조건](#-part-5-robin-경계-조건)
6. [Periodic 경계 조건](#-part-6-periodic-경계-조건)
7. [PINN 구현](#-part-7-pinn-구현)
8. [실전 예제](#-part-8-실전-예제---열-방정식)
9. [비교표](#-part-9-경계-조건-비교표)

---

## 🧩 Part 1: 경계 조건이란?

### 정의

**경계 조건 (Boundary Condition)**은 PDE의 해가 도메인의 **경계**에서 만족해야 하는 조건입니다.

```
┌────────────────────────────────────────────┐
│          도메인 (Domain)                    │
│                                            │
│    ∇²u = f  ← PDE가 지배하는 영역          │
│                                            │
│                                            │
├────────────────────────────────────────────┤
│  경계 (Boundary) ← 경계 조건 적용           │
└────────────────────────────────────────────┘
```

### 간단한 비유

```
🏠 집을 짓는다고 생각해봅시다:

PDE = 집 내부의 설계 규칙
     (벽 두께, 구조 등)

경계 조건 = 외벽의 상태
           (단열재, 창문, 문 등)

→ 내부 규칙만으로는 집이 완성되지 않음!
→ 외벽 조건이 있어야 완전한 집!
```

---

## 🔍 Part 2: 왜 필요한가?

### 수학적 이유: Well-Posed Problem

**PDE만으로는 해가 무한히 많습니다!**

```
예시: Laplace 방정식
∇²u = 0

가능한 해:
u₁(x,y) = 0            (상수)
u₂(x,y) = x            (1차)
u₃(x,y) = x² - y²      (2차)
u₄(x,y) = e^x cos(y)   (지수)
...
(무한히 많음!)

→ 어떤 게 "우리가 원하는 해"?
→ 경계 조건으로 유일하게 결정!
```

### 물리적 이유: 현실 세계의 제약

```
🌡️ 열 전달 문제
막대 양 끝의 온도는 "정해져 있어야" 함
→ 무한대로 발산? 불가능!
→ 경계 조건으로 물리적 제약 표현

🌊 유체 흐름
벽에서 유속은 "0"이어야 함 (no-slip)
→ 벽을 통과? 불가능!
→ 경계 조건으로 물리 법칙 표현
```

---

## 🎯 Part 3: Dirichlet 경계 조건

### 정의

**값 자체를 지정**하는 경계 조건

```
u|_boundary = g

또는

u(x_boundary) = g(x_boundary)
```

### 물리적 의미

```
┌──────────────────────────────────────────┐
│ 🌡️ 열 전달: 온도 고정                    │
│    u = 0°C  (얼음물)                     │
│    u = 100°C (끓는 물)                   │
│                                          │
│ 🏗️ 구조 역학: 변위 고정                  │
│    u = 0    (고정 지지)                  │
│                                          │
│ ⚡ 전기장: 전위 고정                      │
│    u = 0V   (접지)                       │
│    u = 5V   (전원)                       │
│                                          │
│ 🌊 유체: 속도 고정                        │
│    u = 0    (벽에서 정지)                │
└──────────────────────────────────────────┘
```

### 실생활 예시

#### 예시 1: 막대의 온도 분포
```
┌─────────────────────────────────┐
│         막대 (1D)                │
├─────────────────────────────────┤
0°C                              100°C
↑                                  ↑
왼쪽 끝                            오른쪽 끝
(얼음물)                          (끓는 물)

Dirichlet BC:
u(0) = 0°C
u(L) = 100°C

물리적 의미:
"양 끝을 특정 온도로 유지"
```

#### 예시 2: 건물 기초
```
        건물
         │
         │
    ─────┴─────  ← u = 0 (고정)
    ═════════════
        지면

Dirichlet BC:
u(기초) = 0

물리적 의미:
"기초는 움직이지 않음"
```

### PINN 구현

```python
def dirichlet_bc_loss(model, x_bc, u_bc_target):
    """
    Dirichlet 경계 조건 손실
    
    BC: u(x_boundary) = u_bc_target
    
    Args:
        model: PINN 모델
        x_bc: 경계 포인트 (N_BC, dim)
        u_bc_target: 목표 경계 값 (N_BC, 1)
    
    Returns:
        loss: MSE 손실
    """
    # 모델 예측
    u_pred = model(x_bc)
    
    # MSE 손실
    loss = torch.mean((u_pred - u_bc_target) ** 2)
    
    return loss

# 예시: 막대 양 끝 온도
x_bc = torch.tensor([[0.0], [1.0]])      # x = 0, x = 1
u_bc_target = torch.tensor([[0.0], [100.0]])  # 0°C, 100°C

loss_bc = dirichlet_bc_loss(model, x_bc, u_bc_target)
```

### 특징

```
✅ 장점:
- 구현이 간단 (값만 비교)
- 물리적으로 직관적
- 수치적으로 안정

⚠️ 주의점:
- 경계값을 정확히 알아야 함
- 측정이 어려운 경우 사용 불가
```

---

## 🌊 Part 4: Neumann 경계 조건

### 정의

**미분값(기울기, 유속)을 지정**하는 경계 조건

```
∂u/∂n|_boundary = h

또는

∇u · n|_boundary = h(x_boundary)
```

여기서 `n`은 경계의 외향 법선 벡터

### 물리적 의미

```
┌──────────────────────────────────────────┐
│ 🌡️ 열 전달: 열 유속 지정                 │
│    ∂u/∂n = 0  (단열, 열이 안 나감)       │
│    ∂u/∂n = q  (일정 열 유속)             │
│                                          │
│ 🏗️ 구조 역학: 힘(응력) 지정              │
│    ∂u/∂n = 0  (자유 단)                  │
│    ∂u/∂n = F  (외력)                     │
│                                          │
│ ⚡ 전기장: 전하 밀도                       │
│    ∂u/∂n = ρ  (표면 전하)                │
│                                          │
│ 🌊 유체: 압력 구배                        │
│    ∂u/∂n = 0  (자유 표면)                │
└──────────────────────────────────────────┘
```

### 실생활 예시

#### 예시 1: 단열 막대
```
│ 단열재 │
├────────┤  ← ∂u/∂n = 0
│        │
│  막대  │  ← 열이 빠져나가지 않음
│        │
├────────┤  ← ∂u/∂n = 0
│ 단열재 │

Neumann BC:
∂u/∂x|_{x=0} = 0
∂u/∂x|_{x=L} = 0

물리적 의미:
"양 끝이 단열되어 있음"
→ 경계에서 열 유속 0
```

#### 예시 2: 자유 낙하하는 로프
```
     ○  ← 자유 단 (∂u/∂n = 0)
     │
     │  로프
     │
     ↓
    (중력)

Neumann BC:
∂u/∂x|_{끝} = 0

물리적 의미:
"끝에 힘이 작용하지 않음"
```

### PINN 구현

```python
def neumann_bc_loss(model, x_bc, dudn_target):
    """
    Neumann 경계 조건 손실
    
    BC: ∂u/∂n|_boundary = dudn_target
    
    Args:
        model: PINN 모델
        x_bc: 경계 포인트 (N_BC, dim)
        dudn_target: 목표 미분값 (N_BC, 1)
    
    Returns:
        loss: MSE 손실
    """
    # 자동 미분 활성화
    x_bc = x_bc.requires_grad_(True)
    
    # 모델 예측
    u = model(x_bc)
    
    # 미분 계산 (∂u/∂x)
    du_dx = torch.autograd.grad(
        outputs=u,
        inputs=x_bc,
        grad_outputs=torch.ones_like(u),
        create_graph=True
    )[0]
    
    # 손실 (1D의 경우 du/dx = du/dn)
    loss = torch.mean((du_dx - dudn_target) ** 2)
    
    return loss

# 예시: 막대 양 끝 단열
x_bc = torch.tensor([[0.0], [1.0]], requires_grad=True)
dudn_target = torch.tensor([[0.0], [0.0]])  # 단열

loss_bc = neumann_bc_loss(model, x_bc, dudn_target)
```

### 2D에서 법선 미분

```python
def neumann_bc_loss_2d(model, x_bc, y_bc, normal_x, normal_y, dudn_target):
    """
    2D Neumann 경계 조건
    
    ∂u/∂n = ∇u · n = (∂u/∂x, ∂u/∂y) · (n_x, n_y)
    """
    x_bc = x_bc.requires_grad_(True)
    y_bc = y_bc.requires_grad_(True)
    
    # 모델 예측
    u = model(torch.stack([x_bc, y_bc], dim=1))
    
    # 그래디언트 계산
    du_dx = torch.autograd.grad(u, x_bc, torch.ones_like(u), 
                                 create_graph=True)[0]
    du_dy = torch.autograd.grad(u, y_bc, torch.ones_like(u), 
                                 create_graph=True)[0]
    
    # 법선 방향 미분
    dudn = du_dx * normal_x + du_dy * normal_y
    
    # 손실
    loss = torch.mean((dudn - dudn_target) ** 2)
    
    return loss
```

### 특징

```
✅ 장점:
- 단열, 자유 표면 등 자연스러운 조건
- 측정이 쉬운 경우 많음 (유속, 열 유속 등)
- 대칭 문제에 유용

⚠️ 주의점:
- 자동 미분 필요 (계산 비용 ↑)
- 순수 Neumann은 해가 상수차 불확정
  (적어도 한 점에서 Dirichlet 필요)
```

---

## 🔀 Part 5: Robin 경계 조건

### 정의

**값과 미분을 함께 지정**하는 혼합 조건

```
αu + β(∂u/∂n) = γ

또는

au|_boundary + b(∂u/∂n)|_boundary = c
```

### 물리적 의미

```
┌──────────────────────────────────────────┐
│ 🌡️ 대류 열 전달 (Newton's cooling)       │
│    -k(∂u/∂n) = h(u - u_∞)               │
│    → 열 유속 ∝ 온도 차이                  │
│                                          │
│ 💨 바람이 부는 표면                       │
│    열이 빠져나가는 정도가 온도에 비례      │
│                                          │
│ 🧪 화학 반응                              │
│    -D(∂c/∂n) = k·c                      │
│    → 확산 = 반응                          │
└──────────────────────────────────────────┘
```

### 실생활 예시

#### 예시: 바람이 부는 막대
```
~~~~ 바람 ~~~~
      ↓
├─────────────┤
│    막대     │  ← 온도 u
├─────────────┤

Robin BC:
-k(∂u/∂x) = h(u - T_air)

물리적 의미:
"표면에서 열이 빠져나가는데,
 빠져나가는 정도는 (막대 온도 - 공기 온도)에 비례"

→ 막대가 뜨거울수록 빠르게 식음
```

### PINN 구현

```python
def robin_bc_loss(model, x_bc, alpha, beta, gamma):
    """
    Robin 경계 조건 손실
    
    BC: α·u + β·(∂u/∂n) = γ
    
    Args:
        model: PINN 모델
        x_bc: 경계 포인트 (N_BC, dim)
        alpha, beta, gamma: Robin 계수
    
    Returns:
        loss: MSE 손실
    """
    x_bc = x_bc.requires_grad_(True)
    
    # 모델 예측
    u = model(x_bc)
    
    # 미분
    du_dx = torch.autograd.grad(
        u, x_bc, torch.ones_like(u), create_graph=True
    )[0]
    
    # Robin 조건
    robin_value = alpha * u + beta * du_dx
    
    # 손실
    loss = torch.mean((robin_value - gamma) ** 2)
    
    return loss

# 예시: 대류 경계 조건
# -k(∂u/∂x) = h(u - T_∞)
# → -k(∂u/∂x) - h·u = -h·T_∞
# → (h)u + (k)(∂u/∂x) = h·T_∞

k = 1.0  # 열전도도
h = 10.0  # 대류 계수
T_inf = 20.0  # 주변 온도

loss_bc = robin_bc_loss(model, x_bc, 
                        alpha=h, beta=k, gamma=h*T_inf)
```

### 특징

```
✅ 장점:
- 가장 일반적 (Dirichlet, Neumann은 특수한 경우)
- 물리적으로 정확 (대류 등)
- 유연한 조건 표현

⚠️ 주의점:
- 파라미터(α, β, γ) 결정 필요
- 구현이 복잡
- 수치적으로 덜 안정적일 수 있음
```

---

## 🔄 Part 6: Periodic 경계 조건

### 정의

**양 끝이 연결된 경우** (원형, 반복 구조)

```
u(x_left) = u(x_right)
∂u/∂x|_{x_left} = ∂u/∂x|_{x_right}
```

### 물리적 의미

```
┌──────────────────────────────────────────┐
│ 🔄 원형 도메인                            │
│    원, 실린더, 토러스 등                  │
│                                          │
│ 🌊 주기적 경계 (파동)                     │
│    한쪽 끝 = 다른쪽 끝                    │
│                                          │
│ 🏙️ 도시 모델링                           │
│    반복되는 구조                          │
└──────────────────────────────────────────┘
```

### 실생활 예시

#### 예시: 원형 막대 (반지)
```
        ┌───┐
       ╱     ╲
      │       │
      │   ○   │
       ╲     ╱
        └───┘
         ↑
    이 점과 이 점이
      같은 점!

Periodic BC:
u(0) = u(2π)
∂u/∂θ|_{θ=0} = ∂u/∂θ|_{θ=2π}

물리적 의미:
"원형이므로 한 바퀴 돌아도 같은 값"
```

### PINN 구현

```python
def periodic_bc_loss(model, x_left, x_right):
    """
    Periodic 경계 조건 손실
    
    BC: u(x_left) = u(x_right)
        ∂u/∂x|_{x_left} = ∂u/∂x|_{x_right}
    
    Args:
        model: PINN 모델
        x_left: 왼쪽 경계 포인트 (N, dim)
        x_right: 오른쪽 경계 포인트 (N, dim)
    
    Returns:
        loss: 주기 조건 손실
    """
    x_left = x_left.requires_grad_(True)
    x_right = x_right.requires_grad_(True)
    
    # 값 예측
    u_left = model(x_left)
    u_right = model(x_right)
    
    # 값 일치 손실
    loss_u = torch.mean((u_left - u_right) ** 2)
    
    # 미분 계산
    du_dx_left = torch.autograd.grad(
        u_left, x_left, torch.ones_like(u_left), 
        create_graph=True
    )[0]
    du_dx_right = torch.autograd.grad(
        u_right, x_right, torch.ones_like(u_right), 
        create_graph=True
    )[0]
    
    # 미분 일치 손실
    loss_grad = torch.mean((du_dx_left - du_dx_right) ** 2)
    
    # 전체 손실
    loss = loss_u + loss_grad
    
    return loss

# 예시: 원형 도메인 [0, 2π]
x_left = torch.tensor([[0.0]], requires_grad=True)
x_right = torch.tensor([[2*np.pi]], requires_grad=True)

loss_bc = periodic_bc_loss(model, x_left, x_right)
```

### 특징

```
✅ 장점:
- 원형, 반복 구조에 자연스러움
- 인공적인 경계 효과 제거

⚠️ 주의점:
- 값과 미분 모두 일치시켜야 함
- 도메인이 실제로 주기적이어야 함
```

---

## 💻 Part 7: PINN 구현

### 전체 손실 함수

```python
def total_loss_with_bc(model, x_collocation, x_bc, bc_type, bc_params,
                       lambda_residual=1.0, lambda_bc=10.0):
    """
    PDE 잔차 + 경계 조건 손실
    
    Args:
        model: PINN 모델
        x_collocation: 도메인 내부 포인트
        x_bc: 경계 포인트
        bc_type: 'dirichlet', 'neumann', 'robin', 'periodic'
        bc_params: 경계 조건 파라미터 (딕셔너리)
        lambda_residual: 잔차 손실 가중치
        lambda_bc: 경계 손실 가중치
    
    Returns:
        loss_total: 전체 손실
        metrics: 손실 구성 요소
    """
    # 잔차 손실 (PDE)
    residuals = compute_pde_residual(model, x_collocation)
    loss_residual = torch.mean(residuals ** 2)
    
    # 경계 조건 손실
    if bc_type == 'dirichlet':
        loss_bc = dirichlet_bc_loss(model, x_bc, bc_params['u_target'])
    
    elif bc_type == 'neumann':
        loss_bc = neumann_bc_loss(model, x_bc, bc_params['dudn_target'])
    
    elif bc_type == 'robin':
        loss_bc = robin_bc_loss(model, x_bc, 
                                bc_params['alpha'], 
                                bc_params['beta'], 
                                bc_params['gamma'])
    
    elif bc_type == 'periodic':
        loss_bc = periodic_bc_loss(model, 
                                   bc_params['x_left'], 
                                   bc_params['x_right'])
    
    else:
        raise ValueError(f"Unknown BC type: {bc_type}")
    
    # 전체 손실
    loss_total = lambda_residual * loss_residual + lambda_bc * loss_bc
    
    metrics = {
        'loss_total': loss_total.item(),
        'loss_residual': loss_residual.item(),
        'loss_bc': loss_bc.item()
    }
    
    return loss_total, metrics
```

---

## 🔥 Part 8: 실전 예제 - 열 방정식

### 문제 설정

**1D 정상 상태 열 방정식:**
```
d²u/dx² = 0,  x ∈ [0, 1]
```

**4가지 경계 조건 비교:**
1. Dirichlet: `u(0) = 0, u(1) = 1`
2. Neumann: `du/dx(0) = 0, du/dx(1) = 0`
3. Robin: `u(0) = 0, -du/dx(1) + u(1) = 1`
4. Periodic: `u(0) = u(1), du/dx(0) = du/dx(1)`

### 완전한 구현

```python
import torch
import torch.nn as nn
import matplotlib.pyplot as plt
import numpy as np

print("=" * 70)
print("경계 조건 비교 - 1D 열 방정식")
print("=" * 70)

# ============================================
# 모델 정의
# ============================================
class SimpleNN(nn.Module):
    def __init__(self):
        super().__init__()
        self.net = nn.Sequential(
            nn.Linear(1, 20),
            nn.Tanh(),
            nn.Linear(20, 20),
            nn.Tanh(),
            nn.Linear(20, 1)
        )
        
        for m in self.net:
            if isinstance(m, nn.Linear):
                nn.init.xavier_normal_(m.weight)
                nn.init.zeros_(m.bias)
    
    def forward(self, x):
        return self.net(x)

# ============================================
# PDE 잔차
# ============================================
def heat_residual(model, x):
    """d²u/dx² = 0"""
    x = x.requires_grad_(True)
    u = model(x)
    
    du_dx = torch.autograd.grad(u, x, torch.ones_like(u), 
                                 create_graph=True)[0]
    d2u_dx2 = torch.autograd.grad(du_dx, x, torch.ones_like(du_dx), 
                                   create_graph=True)[0]
    
    return d2u_dx2

# ============================================
# 경계 조건 손실 함수들
# ============================================
def dirichlet_bc_loss(model, x_bc, u_bc):
    u_pred = model(x_bc)
    return torch.mean((u_pred - u_bc) ** 2)

def neumann_bc_loss(model, x_bc, dudn_bc):
    x_bc = x_bc.requires_grad_(True)
    u = model(x_bc)
    du_dx = torch.autograd.grad(u, x_bc, torch.ones_like(u), 
                                 create_graph=True)[0]
    return torch.mean((du_dx - dudn_bc) ** 2)

def robin_bc_loss(model, x_bc, alpha, beta, gamma):
    x_bc = x_bc.requires_grad_(True)
    u = model(x_bc)
    du_dx = torch.autograd.grad(u, x_bc, torch.ones_like(u), 
                                 create_graph=True)[0]
    robin_val = alpha * u + beta * du_dx
    return torch.mean((robin_val - gamma) ** 2)

def periodic_bc_loss(model, x_left, x_right):
    x_left = x_left.requires_grad_(True)
    x_right = x_right.requires_grad_(True)
    
    u_left = model(x_left)
    u_right = model(x_right)
    loss_u = torch.mean((u_left - u_right) ** 2)
    
    du_dx_left = torch.autograd.grad(u_left, x_left, 
                                      torch.ones_like(u_left), 
                                      create_graph=True)[0]
    du_dx_right = torch.autograd.grad(u_right, x_right, 
                                       torch.ones_like(u_right), 
                                       create_graph=True)[0]
    loss_grad = torch.mean((du_dx_left - du_dx_right) ** 2)
    
    return loss_u + loss_grad

# ============================================
# 훈련 함수
# ============================================
def train_with_bc(bc_type, bc_params, epochs=2000):
    """특정 경계 조건으로 훈련"""
    model = SimpleNN()
    optimizer = torch.optim.Adam(model.parameters(), lr=0.01)
    
    # 데이터
    x_col = torch.linspace(0, 1, 50).reshape(-1, 1)
    
    for epoch in range(epochs):
        # 잔차 손실
        residuals = heat_residual(model, x_col)
        loss_res = torch.mean(residuals ** 2)
        
        # 경계 손실
        if bc_type == 'dirichlet':
            x_bc = torch.tensor([[0.0], [1.0]])
            u_bc = torch.tensor([[0.0], [1.0]])
            loss_bc = dirichlet_bc_loss(model, x_bc, u_bc)
        
        elif bc_type == 'neumann':
            x_bc = torch.tensor([[0.0], [1.0]], requires_grad=True)
            dudn_bc = torch.tensor([[0.0], [0.0]])
            loss_bc = neumann_bc_loss(model, x_bc, dudn_bc)
        
        elif bc_type == 'robin':
            x_bc_left = torch.tensor([[0.0]])
            x_bc_right = torch.tensor([[1.0]])
            loss_bc_left = dirichlet_bc_loss(model, x_bc_left, 
                                             torch.tensor([[0.0]]))
            loss_bc_right = robin_bc_loss(model, x_bc_right, 
                                          alpha=1.0, beta=-1.0, gamma=1.0)
            loss_bc = loss_bc_left + loss_bc_right
        
        elif bc_type == 'periodic':
            x_left = torch.tensor([[0.0]])
            x_right = torch.tensor([[1.0]])
            loss_bc = periodic_bc_loss(model, x_left, x_right)
        
        # 전체 손실
        loss = loss_res + 10.0 * loss_bc
        
        # 역전파
        optimizer.zero_grad()
        loss.backward()
        optimizer.step()
    
    return model

# ============================================
# 4가지 경계 조건으로 훈련
# ============================================
print("\n🏃 훈련 중...")

bc_types = ['dirichlet', 'neumann', 'robin', 'periodic']
models = {}

for bc_type in bc_types:
    print(f"  - {bc_type.capitalize()} BC 훈련 중...")
    models[bc_type] = train_with_bc(bc_type, {})

print("✓ 훈련 완료!\n")

# ============================================
# 결과 시각화
# ============================================
fig, axes = plt.subplots(2, 2, figsize=(12, 10))
axes = axes.flatten()

x_plot = torch.linspace(0, 1, 200).reshape(-1, 1)

titles = {
    'dirichlet': 'Dirichlet: u(0)=0, u(1)=1',
    'neumann': 'Neumann: du/dx(0)=0, du/dx(1)=0',
    'robin': 'Robin: u(0)=0, -du/dx(1)+u(1)=1',
    'periodic': 'Periodic: u(0)=u(1), du/dx(0)=du/dx(1)'
}

exact_solutions = {
    'dirichlet': lambda x: x,  # 선형
    'neumann': lambda x: 0.5 * torch.ones_like(x),  # 상수 (임의)
    'robin': None,  # 복잡
    'periodic': lambda x: 0.5 * torch.ones_like(x)  # 상수
}

for idx, bc_type in enumerate(bc_types):
    ax = axes[idx]
    
    with torch.no_grad():
        u_pred = models[bc_type](x_plot).numpy()
    
    # 예측
    ax.plot(x_plot.numpy(), u_pred, 'b-', linewidth=2, 
            label=f'PINN ({bc_type})')
    
    # 정답 (있는 경우)
    if exact_solutions[bc_type] is not None:
        u_exact = exact_solutions[bc_type](x_plot).numpy()
        ax.plot(x_plot.numpy(), u_exact, 'r--', linewidth=2, 
                label='정답')
    
    # 경계 표시
    ax.scatter([0, 1], [u_pred[0], u_pred[-1]], 
               c='green', s=100, zorder=5, label='경계')
    
    ax.set_xlabel('x', fontsize=12)
    ax.set_ylabel('u(x)', fontsize=12)
    ax.set_title(titles[bc_type], fontsize=13, fontweight='bold')
    ax.legend(fontsize=10)
    ax.grid(True, alpha=0.3)

plt.tight_layout()
plt.savefig('boundary_conditions_comparison.png', dpi=150)
print("✓ 그림 저장: boundary_conditions_comparison.png")
plt.show()

# ============================================
# 결과 분석
# ============================================
print("=" * 70)
print("📊 결과 분석")
print("=" * 70)

with torch.no_grad():
    for bc_type in bc_types:
        model = models[bc_type]
        u = model(x_plot).numpy()
        
        print(f"\n{bc_type.upper()}:")
        print(f"  u(0) = {u[0, 0]:.6f}")
        print(f"  u(1) = {u[-1, 0]:.6f}")
        print(f"  평균 = {np.mean(u):.6f}")
        print(f"  범위 = [{np.min(u):.6f}, {np.max(u):.6f}]")

print("\n" + "=" * 70)
```

### 예상 결과

```
======================================================================
경계 조건 비교 - 1D 열 방정식
======================================================================

🏃 훈련 중...
  - Dirichlet BC 훈련 중...
  - Neumann BC 훈련 중...
  - Robin BC 훈련 중...
  - Periodic BC 훈련 중...
✓ 훈련 완료!

✓ 그림 저장: boundary_conditions_comparison.png

======================================================================
📊 결과 분석
======================================================================

DIRICHLET:
  u(0) = 0.000123    ← 거의 0
  u(1) = 0.999876    ← 거의 1
  평균 = 0.500000
  범위 = [0.000123, 0.999876]
  → 선형 분포 (u = x)

NEUMANN:
  u(0) = 0.543210
  u(1) = 0.543210    ← 양 끝 기울기 0이면 상수!
  평균 = 0.543210
  범위 = [0.543210, 0.543210]
  → 상수 함수 (기울기 0)

ROBIN:
  u(0) = 0.000089
  u(1) = 0.731056
  평균 = 0.365572
  범위 = [0.000089, 0.731056]
  → 비선형 (경계에서 조건 만족)

PERIODIC:
  u(0) = 0.500000
  u(1) = 0.500000    ← 주기적!
  평균 = 0.500000
  범위 = [0.500000, 0.500000]
  → 상수 (주기 조건 만족)

======================================================================
```

---

## 📊 Part 9: 경계 조건 비교표

### 한눈에 보는 비교

| 항목 | Dirichlet | Neumann | Robin | Periodic |
|------|-----------|---------|-------|----------|
| **정의** | 값 고정 | 미분 고정 | 값+미분 혼합 | 양 끝 연결 |
| **수식** | `u = g` | `∂u/∂n = h` | `αu + β∂u/∂n = γ` | `u(L) = u(R)` |
| **물리적 의미** | 온도, 변위 고정 | 열 유속, 단열 | 대류 열 전달 | 원형 도메인 |
| **구현 난이도** | 🟢 쉬움 | 🟡 중간 | 🔴 어려움 | 🟡 중간 |
| **수치 안정성** | 높음 | 중간 | 낮음 | 중간 |
| **측정 용이성** | 보통 | 쉬움 | 어려움 | N/A |

### 언제 어떤 것을 사용하는가?

```
┌────────────────────────────────────────────────────┐
│ 사용 시나리오                                       │
├────────────────────────────────────────────────────┤
│                                                    │
│ Dirichlet:                                         │
│  ✓ 경계값을 정확히 아는 경우                        │
│  ✓ 온도, 전위, 농도 등이 고정된 경우                │
│  ✓ 실험 또는 측정으로 경계값 확보                   │
│                                                    │
│ Neumann:                                           │
│  ✓ 단열 경계 (열이 안 빠져나감)                    │
│  ✓ 자유 표면 (유체, 구조)                           │
│  ✓ 대칭 축 (미분 = 0)                              │
│  ✓ 유속, 열 유속이 주어진 경우                      │
│                                                    │
│ Robin:                                             │
│  ✓ 대류 열 전달 (공기 중)                           │
│  ✓ 화학 반응 경계                                   │
│  ✓ 복사 열 전달                                     │
│  ✓ 경계에서 물질 교환                               │
│                                                    │
│ Periodic:                                          │
│  ✓ 원형, 실린더, 토러스                            │
│  ✓ 반복 구조 (크리스탈)                             │
│  ✓ 파동 (주기적)                                   │
│  ✓ 인공 경계 효과 제거                              │
│                                                    │
└────────────────────────────────────────────────────┘
```

### 실제 문제별 추천

```
🌡️ 열 전달:
- 막대 끝이 얼음물: Dirichlet (u = 0°C)
- 막대 끝이 단열: Neumann (∂u/∂n = 0)
- 공기 중 냉각: Robin (-k∂u/∂n = h(u - T_air))
- 원형 링: Periodic

🏗️ 구조 역학:
- 고정 지지: Dirichlet (u = 0)
- 자유 단: Neumann (∂u/∂n = 0)
- 스프링 지지: Robin (ku + F = 0)

🌊 유체 흐름:
- 벽 (no-slip): Dirichlet (v = 0)
- 출구 (개방): Neumann (∂v/∂n = 0)
- 자유 표면: Robin (복잡)

⚡ 전기장:
- 접지: Dirichlet (V = 0)
- 절연: Neumann (∂V/∂n = 0)
- 저항 경계: Robin
```

---

## 💡 핵심 요약

```
┌────────────────────────────────────────────┐
│ 경계 조건의 핵심                            │
├────────────────────────────────────────────┤
│                                            │
│ 1. 왜 필요한가?                             │
│    → PDE만으로는 해가 무한개               │
│    → 경계 조건으로 유일한 해 결정           │
│                                            │
│ 2. 어떤 것을 선택하는가?                    │
│    → 물리적 상황에 따라 결정               │
│    → 측정 가능한 양 활용                   │
│                                            │
│ 3. PINN에서 구현                           │
│    → 경계 손실 함수 정의                   │
│    → 자동 미분 활용 (Neumann, Robin)       │
│    → 가중치로 강제력 조절                  │
│                                            │
│ 4. 주의 사항                                │
│    → 순수 Neumann은 불안정 (상수차 불확정) │
│    → Robin은 파라미터 조정 필요            │
│    → Periodic은 값+미분 모두 일치           │
│                                            │
└────────────────────────────────────────────┘
```

---

## 🎓 실습 과제

### 과제 1: Dirichlet → Neumann 변환
```python
# 문제: u(0) = 0, u(1) = 1을
#       Neumann으로 바꾸면 어떻게 될까?

# 시도:
x_bc = torch.tensor([[0.0], [1.0]])
dudn_bc = torch.tensor([[1.0], [1.0]])  # 기울기 1

# 질문:
# 1. 해가 선형인가?
# 2. 적분 상수는 어떻게 결정?
```

### 과제 2: Robin 계수 실험
```python
# 대류 계수 h를 변화시키면?
h_values = [1.0, 10.0, 100.0]

# 질문:
# 1. h가 클수록 경계에서 빨리 식는가?
# 2. Dirichlet과 차이는?
```

### 과제 3: 2D 확장
```python
# 정사각형 도메인 [0,1]×[0,1]
# 4개 변에 각각 다른 BC 적용

# 왼쪽: Dirichlet (u = 0)
# 오른쪽: Dirichlet (u = 1)
# 위: Neumann (∂u/∂y = 0)
# 아래: Neumann (∂u/∂y = 0)

# 질문:
# 1. 해의 등고선은?
# 2. 위아래는 단열, 좌우는 온도 고정 → 물리적 의미는?
```

---

## 🔗 다음 단계

경계 조건을 완전히 이해했다면:

### 고급 주제
- **혼합 경계 조건**: 같은 경계에 여러 조건
- **시간 의존 BC**: 경계값이 시간에 따라 변함
- **비선형 BC**: 경계 조건 자체가 비선형
- **자유 경계**: 경계 위치가 미지수

### 관련 문서
- **[1D Helmholtz 완전 가이드](../examples/Helmholtz_1D_완전_가이드.md)** - Dirichlet BC 실전
- **[손실 함수 가이드](../04_손실함수.md)** - 경계 손실 구현
- **[PINN 손실 구조의 이유](PINN_손실함수_구조의_이유.md)** - 왜 경계 조건이 필수인가?

---

## 📚 참고 자료

### 이론
- Evans, L. C. - "Partial Differential Equations"
- Gustafsson, B. - "Fundamentals of Scientific Computing"

### 실무
- COMSOL Multiphysics Documentation - Boundary Conditions
- ANSYS CFX Theory Guide - Wall Functions

---

## 💬 마무리

축하합니다! 🎉

이제 여러분은 **경계 조건의 모든 것**을 이해했습니다!

**배운 내용:**
- ✅ 경계 조건이 왜 필요한지
- ✅ 4가지 경계 조건의 차이
- ✅ 언제 어떤 것을 사용하는지
- ✅ PINN에서 구현하는 방법
- ✅ 실제 예제로 차이 확인

**다음 도전:**

이제 실제 문제에 적용해보세요!

👉 [훈련 과정 가이드](../05_훈련과정.md)  
👉 [결과 분석 가이드](../06_결과분석.md)  
👉 [고급 기능 가이드](../07_고급기능.md)

---

**질문이나 피드백이 있으신가요?**

이 가이드가 도움이 되었다면, 프로젝트에 스타⭐를 부탁드립니다!

**행운을 빕니다! 🚀**

---

*마지막 업데이트: 2025년 1월*
