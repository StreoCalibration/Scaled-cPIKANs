# ê²½ê³„ ì¡°ê±´ ì™„ì „ ê°€ì´ë“œ ğŸ”²

> **ì£¼ì œ:** Dirichlet, Neumann, Robin, Periodic ê²½ê³„ ì¡°ê±´ì˜ ëª¨ë“  ê²ƒ  
> **ë‚œì´ë„:** ì¤‘ê¸‰  
> **ì†Œìš” ì‹œê°„:** 1ì‹œê°„  
> **ì‚¬ì „ ì§€ì‹:** PDE ê¸°ì´ˆ, ë¯¸ì ë¶„

---

## ğŸ¯ í•™ìŠµ ëª©í‘œ

ì´ ê°€ì´ë“œë¥¼ ë§ˆì¹˜ë©´:

- âœ… ê²½ê³„ ì¡°ê±´ì´ ì™œ í•„ìš”í•œì§€ ì´í•´
- âœ… 4ê°€ì§€ ê²½ê³„ ì¡°ê±´ì˜ ë¬¼ë¦¬ì  ì˜ë¯¸ íŒŒì•…
- âœ… ì–¸ì œ ì–´ë–¤ ê²½ê³„ ì¡°ê±´ì„ ì‚¬ìš©í•˜ëŠ”ì§€ ê²°ì • ê°€ëŠ¥
- âœ… PINNì—ì„œ ê° ê²½ê³„ ì¡°ê±´ êµ¬í˜„
- âœ… ì‹¤ì œ ì˜ˆì œë¡œ ì°¨ì´ í™•ì¸

---

## ğŸ“š ëª©ì°¨

1. [ê²½ê³„ ì¡°ê±´ì´ë€?](#-part-1-ê²½ê³„-ì¡°ê±´ì´ë€)
2. [ì™œ í•„ìš”í•œê°€?](#-part-2-ì™œ-í•„ìš”í•œê°€)
3. [Dirichlet ê²½ê³„ ì¡°ê±´](#-part-3-dirichlet-ê²½ê³„-ì¡°ê±´)
4. [Neumann ê²½ê³„ ì¡°ê±´](#-part-4-neumann-ê²½ê³„-ì¡°ê±´)
5. [Robin ê²½ê³„ ì¡°ê±´](#-part-5-robin-ê²½ê³„-ì¡°ê±´)
6. [Periodic ê²½ê³„ ì¡°ê±´](#-part-6-periodic-ê²½ê³„-ì¡°ê±´)
7. [PINN êµ¬í˜„](#-part-7-pinn-êµ¬í˜„)
8. [ì‹¤ì „ ì˜ˆì œ](#-part-8-ì‹¤ì „-ì˜ˆì œ---ì—´-ë°©ì •ì‹)
9. [ë¹„êµí‘œ](#-part-9-ê²½ê³„-ì¡°ê±´-ë¹„êµí‘œ)

---

## ğŸ§© Part 1: ê²½ê³„ ì¡°ê±´ì´ë€?

### ì •ì˜

**ê²½ê³„ ì¡°ê±´ (Boundary Condition)**ì€ PDEì˜ í•´ê°€ ë„ë©”ì¸ì˜ **ê²½ê³„**ì—ì„œ ë§Œì¡±í•´ì•¼ í•˜ëŠ” ì¡°ê±´ì…ë‹ˆë‹¤.

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚          ë„ë©”ì¸ (Domain)                    â”‚
â”‚                                            â”‚
â”‚    âˆ‡Â²u = f  â† PDEê°€ ì§€ë°°í•˜ëŠ” ì˜ì—­          â”‚
â”‚                                            â”‚
â”‚                                            â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚  ê²½ê³„ (Boundary) â† ê²½ê³„ ì¡°ê±´ ì ìš©           â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

### ê°„ë‹¨í•œ ë¹„ìœ 

```
ğŸ  ì§‘ì„ ì§“ëŠ”ë‹¤ê³  ìƒê°í•´ë´…ì‹œë‹¤:

PDE = ì§‘ ë‚´ë¶€ì˜ ì„¤ê³„ ê·œì¹™
     (ë²½ ë‘ê»˜, êµ¬ì¡° ë“±)

ê²½ê³„ ì¡°ê±´ = ì™¸ë²½ì˜ ìƒíƒœ
           (ë‹¨ì—´ì¬, ì°½ë¬¸, ë¬¸ ë“±)

â†’ ë‚´ë¶€ ê·œì¹™ë§Œìœ¼ë¡œëŠ” ì§‘ì´ ì™„ì„±ë˜ì§€ ì•ŠìŒ!
â†’ ì™¸ë²½ ì¡°ê±´ì´ ìˆì–´ì•¼ ì™„ì „í•œ ì§‘!
```

---

## ğŸ” Part 2: ì™œ í•„ìš”í•œê°€?

### ìˆ˜í•™ì  ì´ìœ : Well-Posed Problem

**PDEë§Œìœ¼ë¡œëŠ” í•´ê°€ ë¬´í•œíˆ ë§ìŠµë‹ˆë‹¤!**

```
ì˜ˆì‹œ: Laplace ë°©ì •ì‹
âˆ‡Â²u = 0

ê°€ëŠ¥í•œ í•´:
uâ‚(x,y) = 0            (ìƒìˆ˜)
uâ‚‚(x,y) = x            (1ì°¨)
uâ‚ƒ(x,y) = xÂ² - yÂ²      (2ì°¨)
uâ‚„(x,y) = e^x cos(y)   (ì§€ìˆ˜)
...
(ë¬´í•œíˆ ë§ìŒ!)

â†’ ì–´ë–¤ ê²Œ "ìš°ë¦¬ê°€ ì›í•˜ëŠ” í•´"?
â†’ ê²½ê³„ ì¡°ê±´ìœ¼ë¡œ ìœ ì¼í•˜ê²Œ ê²°ì •!
```

### ë¬¼ë¦¬ì  ì´ìœ : í˜„ì‹¤ ì„¸ê³„ì˜ ì œì•½

```
ğŸŒ¡ï¸ ì—´ ì „ë‹¬ ë¬¸ì œ
ë§‰ëŒ€ ì–‘ ëì˜ ì˜¨ë„ëŠ” "ì •í•´ì ¸ ìˆì–´ì•¼" í•¨
â†’ ë¬´í•œëŒ€ë¡œ ë°œì‚°? ë¶ˆê°€ëŠ¥!
â†’ ê²½ê³„ ì¡°ê±´ìœ¼ë¡œ ë¬¼ë¦¬ì  ì œì•½ í‘œí˜„

ğŸŒŠ ìœ ì²´ íë¦„
ë²½ì—ì„œ ìœ ì†ì€ "0"ì´ì–´ì•¼ í•¨ (no-slip)
â†’ ë²½ì„ í†µê³¼? ë¶ˆê°€ëŠ¥!
â†’ ê²½ê³„ ì¡°ê±´ìœ¼ë¡œ ë¬¼ë¦¬ ë²•ì¹™ í‘œí˜„
```

---

## ğŸ¯ Part 3: Dirichlet ê²½ê³„ ì¡°ê±´

### ì •ì˜

**ê°’ ìì²´ë¥¼ ì§€ì •**í•˜ëŠ” ê²½ê³„ ì¡°ê±´

```
u|_boundary = g

ë˜ëŠ”

u(x_boundary) = g(x_boundary)
```

### ë¬¼ë¦¬ì  ì˜ë¯¸

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ ğŸŒ¡ï¸ ì—´ ì „ë‹¬: ì˜¨ë„ ê³ ì •                    â”‚
â”‚    u = 0Â°C  (ì–¼ìŒë¬¼)                     â”‚
â”‚    u = 100Â°C (ë“ëŠ” ë¬¼)                   â”‚
â”‚                                          â”‚
â”‚ ğŸ—ï¸ êµ¬ì¡° ì—­í•™: ë³€ìœ„ ê³ ì •                  â”‚
â”‚    u = 0    (ê³ ì • ì§€ì§€)                  â”‚
â”‚                                          â”‚
â”‚ âš¡ ì „ê¸°ì¥: ì „ìœ„ ê³ ì •                      â”‚
â”‚    u = 0V   (ì ‘ì§€)                       â”‚
â”‚    u = 5V   (ì „ì›)                       â”‚
â”‚                                          â”‚
â”‚ ğŸŒŠ ìœ ì²´: ì†ë„ ê³ ì •                        â”‚
â”‚    u = 0    (ë²½ì—ì„œ ì •ì§€)                â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

### ì‹¤ìƒí™œ ì˜ˆì‹œ

#### ì˜ˆì‹œ 1: ë§‰ëŒ€ì˜ ì˜¨ë„ ë¶„í¬
```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚         ë§‰ëŒ€ (1D)                â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
0Â°C                              100Â°C
â†‘                                  â†‘
ì™¼ìª½ ë                            ì˜¤ë¥¸ìª½ ë
(ì–¼ìŒë¬¼)                          (ë“ëŠ” ë¬¼)

Dirichlet BC:
u(0) = 0Â°C
u(L) = 100Â°C

ë¬¼ë¦¬ì  ì˜ë¯¸:
"ì–‘ ëì„ íŠ¹ì • ì˜¨ë„ë¡œ ìœ ì§€"
```

#### ì˜ˆì‹œ 2: ê±´ë¬¼ ê¸°ì´ˆ
```
        ê±´ë¬¼
         â”‚
         â”‚
    â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€  â† u = 0 (ê³ ì •)
    â•â•â•â•â•â•â•â•â•â•â•â•â•
        ì§€ë©´

Dirichlet BC:
u(ê¸°ì´ˆ) = 0

ë¬¼ë¦¬ì  ì˜ë¯¸:
"ê¸°ì´ˆëŠ” ì›€ì§ì´ì§€ ì•ŠìŒ"
```

### PINN êµ¬í˜„

```python
def dirichlet_bc_loss(model, x_bc, u_bc_target):
    """
    Dirichlet ê²½ê³„ ì¡°ê±´ ì†ì‹¤
    
    BC: u(x_boundary) = u_bc_target
    
    Args:
        model: PINN ëª¨ë¸
        x_bc: ê²½ê³„ í¬ì¸íŠ¸ (N_BC, dim)
        u_bc_target: ëª©í‘œ ê²½ê³„ ê°’ (N_BC, 1)
    
    Returns:
        loss: MSE ì†ì‹¤
    """
    # ëª¨ë¸ ì˜ˆì¸¡
    u_pred = model(x_bc)
    
    # MSE ì†ì‹¤
    loss = torch.mean((u_pred - u_bc_target) ** 2)
    
    return loss

# ì˜ˆì‹œ: ë§‰ëŒ€ ì–‘ ë ì˜¨ë„
x_bc = torch.tensor([[0.0], [1.0]])      # x = 0, x = 1
u_bc_target = torch.tensor([[0.0], [100.0]])  # 0Â°C, 100Â°C

loss_bc = dirichlet_bc_loss(model, x_bc, u_bc_target)
```

### íŠ¹ì§•

```
âœ… ì¥ì :
- êµ¬í˜„ì´ ê°„ë‹¨ (ê°’ë§Œ ë¹„êµ)
- ë¬¼ë¦¬ì ìœ¼ë¡œ ì§ê´€ì 
- ìˆ˜ì¹˜ì ìœ¼ë¡œ ì•ˆì •

âš ï¸ ì£¼ì˜ì :
- ê²½ê³„ê°’ì„ ì •í™•íˆ ì•Œì•„ì•¼ í•¨
- ì¸¡ì •ì´ ì–´ë ¤ìš´ ê²½ìš° ì‚¬ìš© ë¶ˆê°€
```

---

## ğŸŒŠ Part 4: Neumann ê²½ê³„ ì¡°ê±´

### ì •ì˜

**ë¯¸ë¶„ê°’(ê¸°ìš¸ê¸°, ìœ ì†)ì„ ì§€ì •**í•˜ëŠ” ê²½ê³„ ì¡°ê±´

```
âˆ‚u/âˆ‚n|_boundary = h

ë˜ëŠ”

âˆ‡u Â· n|_boundary = h(x_boundary)
```

ì—¬ê¸°ì„œ `n`ì€ ê²½ê³„ì˜ ì™¸í–¥ ë²•ì„  ë²¡í„°

### ë¬¼ë¦¬ì  ì˜ë¯¸

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ ğŸŒ¡ï¸ ì—´ ì „ë‹¬: ì—´ ìœ ì† ì§€ì •                 â”‚
â”‚    âˆ‚u/âˆ‚n = 0  (ë‹¨ì—´, ì—´ì´ ì•ˆ ë‚˜ê°)       â”‚
â”‚    âˆ‚u/âˆ‚n = q  (ì¼ì • ì—´ ìœ ì†)             â”‚
â”‚                                          â”‚
â”‚ ğŸ—ï¸ êµ¬ì¡° ì—­í•™: í˜(ì‘ë ¥) ì§€ì •              â”‚
â”‚    âˆ‚u/âˆ‚n = 0  (ììœ  ë‹¨)                  â”‚
â”‚    âˆ‚u/âˆ‚n = F  (ì™¸ë ¥)                     â”‚
â”‚                                          â”‚
â”‚ âš¡ ì „ê¸°ì¥: ì „í•˜ ë°€ë„                       â”‚
â”‚    âˆ‚u/âˆ‚n = Ï  (í‘œë©´ ì „í•˜)                â”‚
â”‚                                          â”‚
â”‚ ğŸŒŠ ìœ ì²´: ì••ë ¥ êµ¬ë°°                        â”‚
â”‚    âˆ‚u/âˆ‚n = 0  (ììœ  í‘œë©´)                â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

### ì‹¤ìƒí™œ ì˜ˆì‹œ

#### ì˜ˆì‹œ 1: ë‹¨ì—´ ë§‰ëŒ€
```
â”‚ ë‹¨ì—´ì¬ â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”¤  â† âˆ‚u/âˆ‚n = 0
â”‚        â”‚
â”‚  ë§‰ëŒ€  â”‚  â† ì—´ì´ ë¹ ì ¸ë‚˜ê°€ì§€ ì•ŠìŒ
â”‚        â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”¤  â† âˆ‚u/âˆ‚n = 0
â”‚ ë‹¨ì—´ì¬ â”‚

Neumann BC:
âˆ‚u/âˆ‚x|_{x=0} = 0
âˆ‚u/âˆ‚x|_{x=L} = 0

ë¬¼ë¦¬ì  ì˜ë¯¸:
"ì–‘ ëì´ ë‹¨ì—´ë˜ì–´ ìˆìŒ"
â†’ ê²½ê³„ì—ì„œ ì—´ ìœ ì† 0
```

#### ì˜ˆì‹œ 2: ììœ  ë‚™í•˜í•˜ëŠ” ë¡œí”„
```
     â—‹  â† ììœ  ë‹¨ (âˆ‚u/âˆ‚n = 0)
     â”‚
     â”‚  ë¡œí”„
     â”‚
     â†“
    (ì¤‘ë ¥)

Neumann BC:
âˆ‚u/âˆ‚x|_{ë} = 0

ë¬¼ë¦¬ì  ì˜ë¯¸:
"ëì— í˜ì´ ì‘ìš©í•˜ì§€ ì•ŠìŒ"
```

### PINN êµ¬í˜„

```python
def neumann_bc_loss(model, x_bc, dudn_target):
    """
    Neumann ê²½ê³„ ì¡°ê±´ ì†ì‹¤
    
    BC: âˆ‚u/âˆ‚n|_boundary = dudn_target
    
    Args:
        model: PINN ëª¨ë¸
        x_bc: ê²½ê³„ í¬ì¸íŠ¸ (N_BC, dim)
        dudn_target: ëª©í‘œ ë¯¸ë¶„ê°’ (N_BC, 1)
    
    Returns:
        loss: MSE ì†ì‹¤
    """
    # ìë™ ë¯¸ë¶„ í™œì„±í™”
    x_bc = x_bc.requires_grad_(True)
    
    # ëª¨ë¸ ì˜ˆì¸¡
    u = model(x_bc)
    
    # ë¯¸ë¶„ ê³„ì‚° (âˆ‚u/âˆ‚x)
    du_dx = torch.autograd.grad(
        outputs=u,
        inputs=x_bc,
        grad_outputs=torch.ones_like(u),
        create_graph=True
    )[0]
    
    # ì†ì‹¤ (1Dì˜ ê²½ìš° du/dx = du/dn)
    loss = torch.mean((du_dx - dudn_target) ** 2)
    
    return loss

# ì˜ˆì‹œ: ë§‰ëŒ€ ì–‘ ë ë‹¨ì—´
x_bc = torch.tensor([[0.0], [1.0]], requires_grad=True)
dudn_target = torch.tensor([[0.0], [0.0]])  # ë‹¨ì—´

loss_bc = neumann_bc_loss(model, x_bc, dudn_target)
```

### 2Dì—ì„œ ë²•ì„  ë¯¸ë¶„

```python
def neumann_bc_loss_2d(model, x_bc, y_bc, normal_x, normal_y, dudn_target):
    """
    2D Neumann ê²½ê³„ ì¡°ê±´
    
    âˆ‚u/âˆ‚n = âˆ‡u Â· n = (âˆ‚u/âˆ‚x, âˆ‚u/âˆ‚y) Â· (n_x, n_y)
    """
    x_bc = x_bc.requires_grad_(True)
    y_bc = y_bc.requires_grad_(True)
    
    # ëª¨ë¸ ì˜ˆì¸¡
    u = model(torch.stack([x_bc, y_bc], dim=1))
    
    # ê·¸ë˜ë””ì–¸íŠ¸ ê³„ì‚°
    du_dx = torch.autograd.grad(u, x_bc, torch.ones_like(u), 
                                 create_graph=True)[0]
    du_dy = torch.autograd.grad(u, y_bc, torch.ones_like(u), 
                                 create_graph=True)[0]
    
    # ë²•ì„  ë°©í–¥ ë¯¸ë¶„
    dudn = du_dx * normal_x + du_dy * normal_y
    
    # ì†ì‹¤
    loss = torch.mean((dudn - dudn_target) ** 2)
    
    return loss
```

### íŠ¹ì§•

```
âœ… ì¥ì :
- ë‹¨ì—´, ììœ  í‘œë©´ ë“± ìì—°ìŠ¤ëŸ¬ìš´ ì¡°ê±´
- ì¸¡ì •ì´ ì‰¬ìš´ ê²½ìš° ë§ìŒ (ìœ ì†, ì—´ ìœ ì† ë“±)
- ëŒ€ì¹­ ë¬¸ì œì— ìœ ìš©

âš ï¸ ì£¼ì˜ì :
- ìë™ ë¯¸ë¶„ í•„ìš” (ê³„ì‚° ë¹„ìš© â†‘)
- ìˆœìˆ˜ Neumannì€ í•´ê°€ ìƒìˆ˜ì°¨ ë¶ˆí™•ì •
  (ì ì–´ë„ í•œ ì ì—ì„œ Dirichlet í•„ìš”)
```

---

## ğŸ”€ Part 5: Robin ê²½ê³„ ì¡°ê±´

### ì •ì˜

**ê°’ê³¼ ë¯¸ë¶„ì„ í•¨ê»˜ ì§€ì •**í•˜ëŠ” í˜¼í•© ì¡°ê±´

```
Î±u + Î²(âˆ‚u/âˆ‚n) = Î³

ë˜ëŠ”

au|_boundary + b(âˆ‚u/âˆ‚n)|_boundary = c
```

### ë¬¼ë¦¬ì  ì˜ë¯¸

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ ğŸŒ¡ï¸ ëŒ€ë¥˜ ì—´ ì „ë‹¬ (Newton's cooling)       â”‚
â”‚    -k(âˆ‚u/âˆ‚n) = h(u - u_âˆ)               â”‚
â”‚    â†’ ì—´ ìœ ì† âˆ ì˜¨ë„ ì°¨ì´                  â”‚
â”‚                                          â”‚
â”‚ ğŸ’¨ ë°”ëŒì´ ë¶€ëŠ” í‘œë©´                       â”‚
â”‚    ì—´ì´ ë¹ ì ¸ë‚˜ê°€ëŠ” ì •ë„ê°€ ì˜¨ë„ì— ë¹„ë¡€      â”‚
â”‚                                          â”‚
â”‚ ğŸ§ª í™”í•™ ë°˜ì‘                              â”‚
â”‚    -D(âˆ‚c/âˆ‚n) = kÂ·c                      â”‚
â”‚    â†’ í™•ì‚° = ë°˜ì‘                          â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

### ì‹¤ìƒí™œ ì˜ˆì‹œ

#### ì˜ˆì‹œ: ë°”ëŒì´ ë¶€ëŠ” ë§‰ëŒ€
```
~~~~ ë°”ëŒ ~~~~
      â†“
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚    ë§‰ëŒ€     â”‚  â† ì˜¨ë„ u
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤

Robin BC:
-k(âˆ‚u/âˆ‚x) = h(u - T_air)

ë¬¼ë¦¬ì  ì˜ë¯¸:
"í‘œë©´ì—ì„œ ì—´ì´ ë¹ ì ¸ë‚˜ê°€ëŠ”ë°,
 ë¹ ì ¸ë‚˜ê°€ëŠ” ì •ë„ëŠ” (ë§‰ëŒ€ ì˜¨ë„ - ê³µê¸° ì˜¨ë„)ì— ë¹„ë¡€"

â†’ ë§‰ëŒ€ê°€ ëœ¨ê±°ìš¸ìˆ˜ë¡ ë¹ ë¥´ê²Œ ì‹ìŒ
```

### PINN êµ¬í˜„

```python
def robin_bc_loss(model, x_bc, alpha, beta, gamma):
    """
    Robin ê²½ê³„ ì¡°ê±´ ì†ì‹¤
    
    BC: Î±Â·u + Î²Â·(âˆ‚u/âˆ‚n) = Î³
    
    Args:
        model: PINN ëª¨ë¸
        x_bc: ê²½ê³„ í¬ì¸íŠ¸ (N_BC, dim)
        alpha, beta, gamma: Robin ê³„ìˆ˜
    
    Returns:
        loss: MSE ì†ì‹¤
    """
    x_bc = x_bc.requires_grad_(True)
    
    # ëª¨ë¸ ì˜ˆì¸¡
    u = model(x_bc)
    
    # ë¯¸ë¶„
    du_dx = torch.autograd.grad(
        u, x_bc, torch.ones_like(u), create_graph=True
    )[0]
    
    # Robin ì¡°ê±´
    robin_value = alpha * u + beta * du_dx
    
    # ì†ì‹¤
    loss = torch.mean((robin_value - gamma) ** 2)
    
    return loss

# ì˜ˆì‹œ: ëŒ€ë¥˜ ê²½ê³„ ì¡°ê±´
# -k(âˆ‚u/âˆ‚x) = h(u - T_âˆ)
# â†’ -k(âˆ‚u/âˆ‚x) - hÂ·u = -hÂ·T_âˆ
# â†’ (h)u + (k)(âˆ‚u/âˆ‚x) = hÂ·T_âˆ

k = 1.0  # ì—´ì „ë„ë„
h = 10.0  # ëŒ€ë¥˜ ê³„ìˆ˜
T_inf = 20.0  # ì£¼ë³€ ì˜¨ë„

loss_bc = robin_bc_loss(model, x_bc, 
                        alpha=h, beta=k, gamma=h*T_inf)
```

### íŠ¹ì§•

```
âœ… ì¥ì :
- ê°€ì¥ ì¼ë°˜ì  (Dirichlet, Neumannì€ íŠ¹ìˆ˜í•œ ê²½ìš°)
- ë¬¼ë¦¬ì ìœ¼ë¡œ ì •í™• (ëŒ€ë¥˜ ë“±)
- ìœ ì—°í•œ ì¡°ê±´ í‘œí˜„

âš ï¸ ì£¼ì˜ì :
- íŒŒë¼ë¯¸í„°(Î±, Î², Î³) ê²°ì • í•„ìš”
- êµ¬í˜„ì´ ë³µì¡
- ìˆ˜ì¹˜ì ìœ¼ë¡œ ëœ ì•ˆì •ì ì¼ ìˆ˜ ìˆìŒ
```

---

## ğŸ”„ Part 6: Periodic ê²½ê³„ ì¡°ê±´

### ì •ì˜

**ì–‘ ëì´ ì—°ê²°ëœ ê²½ìš°** (ì›í˜•, ë°˜ë³µ êµ¬ì¡°)

```
u(x_left) = u(x_right)
âˆ‚u/âˆ‚x|_{x_left} = âˆ‚u/âˆ‚x|_{x_right}
```

### ë¬¼ë¦¬ì  ì˜ë¯¸

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ ğŸ”„ ì›í˜• ë„ë©”ì¸                            â”‚
â”‚    ì›, ì‹¤ë¦°ë”, í† ëŸ¬ìŠ¤ ë“±                  â”‚
â”‚                                          â”‚
â”‚ ğŸŒŠ ì£¼ê¸°ì  ê²½ê³„ (íŒŒë™)                     â”‚
â”‚    í•œìª½ ë = ë‹¤ë¥¸ìª½ ë                    â”‚
â”‚                                          â”‚
â”‚ ğŸ™ï¸ ë„ì‹œ ëª¨ë¸ë§                           â”‚
â”‚    ë°˜ë³µë˜ëŠ” êµ¬ì¡°                          â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

### ì‹¤ìƒí™œ ì˜ˆì‹œ

#### ì˜ˆì‹œ: ì›í˜• ë§‰ëŒ€ (ë°˜ì§€)
```
        â”Œâ”€â”€â”€â”
       â•±     â•²
      â”‚       â”‚
      â”‚   â—‹   â”‚
       â•²     â•±
        â””â”€â”€â”€â”˜
         â†‘
    ì´ ì ê³¼ ì´ ì ì´
      ê°™ì€ ì !

Periodic BC:
u(0) = u(2Ï€)
âˆ‚u/âˆ‚Î¸|_{Î¸=0} = âˆ‚u/âˆ‚Î¸|_{Î¸=2Ï€}

ë¬¼ë¦¬ì  ì˜ë¯¸:
"ì›í˜•ì´ë¯€ë¡œ í•œ ë°”í€´ ëŒì•„ë„ ê°™ì€ ê°’"
```

### PINN êµ¬í˜„

```python
def periodic_bc_loss(model, x_left, x_right):
    """
    Periodic ê²½ê³„ ì¡°ê±´ ì†ì‹¤
    
    BC: u(x_left) = u(x_right)
        âˆ‚u/âˆ‚x|_{x_left} = âˆ‚u/âˆ‚x|_{x_right}
    
    Args:
        model: PINN ëª¨ë¸
        x_left: ì™¼ìª½ ê²½ê³„ í¬ì¸íŠ¸ (N, dim)
        x_right: ì˜¤ë¥¸ìª½ ê²½ê³„ í¬ì¸íŠ¸ (N, dim)
    
    Returns:
        loss: ì£¼ê¸° ì¡°ê±´ ì†ì‹¤
    """
    x_left = x_left.requires_grad_(True)
    x_right = x_right.requires_grad_(True)
    
    # ê°’ ì˜ˆì¸¡
    u_left = model(x_left)
    u_right = model(x_right)
    
    # ê°’ ì¼ì¹˜ ì†ì‹¤
    loss_u = torch.mean((u_left - u_right) ** 2)
    
    # ë¯¸ë¶„ ê³„ì‚°
    du_dx_left = torch.autograd.grad(
        u_left, x_left, torch.ones_like(u_left), 
        create_graph=True
    )[0]
    du_dx_right = torch.autograd.grad(
        u_right, x_right, torch.ones_like(u_right), 
        create_graph=True
    )[0]
    
    # ë¯¸ë¶„ ì¼ì¹˜ ì†ì‹¤
    loss_grad = torch.mean((du_dx_left - du_dx_right) ** 2)
    
    # ì „ì²´ ì†ì‹¤
    loss = loss_u + loss_grad
    
    return loss

# ì˜ˆì‹œ: ì›í˜• ë„ë©”ì¸ [0, 2Ï€]
x_left = torch.tensor([[0.0]], requires_grad=True)
x_right = torch.tensor([[2*np.pi]], requires_grad=True)

loss_bc = periodic_bc_loss(model, x_left, x_right)
```

### íŠ¹ì§•

```
âœ… ì¥ì :
- ì›í˜•, ë°˜ë³µ êµ¬ì¡°ì— ìì—°ìŠ¤ëŸ¬ì›€
- ì¸ê³µì ì¸ ê²½ê³„ íš¨ê³¼ ì œê±°

âš ï¸ ì£¼ì˜ì :
- ê°’ê³¼ ë¯¸ë¶„ ëª¨ë‘ ì¼ì¹˜ì‹œì¼œì•¼ í•¨
- ë„ë©”ì¸ì´ ì‹¤ì œë¡œ ì£¼ê¸°ì ì´ì–´ì•¼ í•¨
```

---

## ğŸ’» Part 7: PINN êµ¬í˜„

### ì „ì²´ ì†ì‹¤ í•¨ìˆ˜

```python
def total_loss_with_bc(model, x_collocation, x_bc, bc_type, bc_params,
                       lambda_residual=1.0, lambda_bc=10.0):
    """
    PDE ì”ì°¨ + ê²½ê³„ ì¡°ê±´ ì†ì‹¤
    
    Args:
        model: PINN ëª¨ë¸
        x_collocation: ë„ë©”ì¸ ë‚´ë¶€ í¬ì¸íŠ¸
        x_bc: ê²½ê³„ í¬ì¸íŠ¸
        bc_type: 'dirichlet', 'neumann', 'robin', 'periodic'
        bc_params: ê²½ê³„ ì¡°ê±´ íŒŒë¼ë¯¸í„° (ë”•ì…”ë„ˆë¦¬)
        lambda_residual: ì”ì°¨ ì†ì‹¤ ê°€ì¤‘ì¹˜
        lambda_bc: ê²½ê³„ ì†ì‹¤ ê°€ì¤‘ì¹˜
    
    Returns:
        loss_total: ì „ì²´ ì†ì‹¤
        metrics: ì†ì‹¤ êµ¬ì„± ìš”ì†Œ
    """
    # ì”ì°¨ ì†ì‹¤ (PDE)
    residuals = compute_pde_residual(model, x_collocation)
    loss_residual = torch.mean(residuals ** 2)
    
    # ê²½ê³„ ì¡°ê±´ ì†ì‹¤
    if bc_type == 'dirichlet':
        loss_bc = dirichlet_bc_loss(model, x_bc, bc_params['u_target'])
    
    elif bc_type == 'neumann':
        loss_bc = neumann_bc_loss(model, x_bc, bc_params['dudn_target'])
    
    elif bc_type == 'robin':
        loss_bc = robin_bc_loss(model, x_bc, 
                                bc_params['alpha'], 
                                bc_params['beta'], 
                                bc_params['gamma'])
    
    elif bc_type == 'periodic':
        loss_bc = periodic_bc_loss(model, 
                                   bc_params['x_left'], 
                                   bc_params['x_right'])
    
    else:
        raise ValueError(f"Unknown BC type: {bc_type}")
    
    # ì „ì²´ ì†ì‹¤
    loss_total = lambda_residual * loss_residual + lambda_bc * loss_bc
    
    metrics = {
        'loss_total': loss_total.item(),
        'loss_residual': loss_residual.item(),
        'loss_bc': loss_bc.item()
    }
    
    return loss_total, metrics
```

---

## ğŸ”¥ Part 8: ì‹¤ì „ ì˜ˆì œ - ì—´ ë°©ì •ì‹

### ë¬¸ì œ ì„¤ì •

**1D ì •ìƒ ìƒíƒœ ì—´ ë°©ì •ì‹:**
```
dÂ²u/dxÂ² = 0,  x âˆˆ [0, 1]
```

**4ê°€ì§€ ê²½ê³„ ì¡°ê±´ ë¹„êµ:**
1. Dirichlet: `u(0) = 0, u(1) = 1`
2. Neumann: `du/dx(0) = 0, du/dx(1) = 0`
3. Robin: `u(0) = 0, -du/dx(1) + u(1) = 1`
4. Periodic: `u(0) = u(1), du/dx(0) = du/dx(1)`

### ì™„ì „í•œ êµ¬í˜„

```python
import torch
import torch.nn as nn
import matplotlib.pyplot as plt
import numpy as np

print("=" * 70)
print("ê²½ê³„ ì¡°ê±´ ë¹„êµ - 1D ì—´ ë°©ì •ì‹")
print("=" * 70)

# ============================================
# ëª¨ë¸ ì •ì˜
# ============================================
class SimpleNN(nn.Module):
    def __init__(self):
        super().__init__()
        self.net = nn.Sequential(
            nn.Linear(1, 20),
            nn.Tanh(),
            nn.Linear(20, 20),
            nn.Tanh(),
            nn.Linear(20, 1)
        )
        
        for m in self.net:
            if isinstance(m, nn.Linear):
                nn.init.xavier_normal_(m.weight)
                nn.init.zeros_(m.bias)
    
    def forward(self, x):
        return self.net(x)

# ============================================
# PDE ì”ì°¨
# ============================================
def heat_residual(model, x):
    """dÂ²u/dxÂ² = 0"""
    x = x.requires_grad_(True)
    u = model(x)
    
    du_dx = torch.autograd.grad(u, x, torch.ones_like(u), 
                                 create_graph=True)[0]
    d2u_dx2 = torch.autograd.grad(du_dx, x, torch.ones_like(du_dx), 
                                   create_graph=True)[0]
    
    return d2u_dx2

# ============================================
# ê²½ê³„ ì¡°ê±´ ì†ì‹¤ í•¨ìˆ˜ë“¤
# ============================================
def dirichlet_bc_loss(model, x_bc, u_bc):
    u_pred = model(x_bc)
    return torch.mean((u_pred - u_bc) ** 2)

def neumann_bc_loss(model, x_bc, dudn_bc):
    x_bc = x_bc.requires_grad_(True)
    u = model(x_bc)
    du_dx = torch.autograd.grad(u, x_bc, torch.ones_like(u), 
                                 create_graph=True)[0]
    return torch.mean((du_dx - dudn_bc) ** 2)

def robin_bc_loss(model, x_bc, alpha, beta, gamma):
    x_bc = x_bc.requires_grad_(True)
    u = model(x_bc)
    du_dx = torch.autograd.grad(u, x_bc, torch.ones_like(u), 
                                 create_graph=True)[0]
    robin_val = alpha * u + beta * du_dx
    return torch.mean((robin_val - gamma) ** 2)

def periodic_bc_loss(model, x_left, x_right):
    x_left = x_left.requires_grad_(True)
    x_right = x_right.requires_grad_(True)
    
    u_left = model(x_left)
    u_right = model(x_right)
    loss_u = torch.mean((u_left - u_right) ** 2)
    
    du_dx_left = torch.autograd.grad(u_left, x_left, 
                                      torch.ones_like(u_left), 
                                      create_graph=True)[0]
    du_dx_right = torch.autograd.grad(u_right, x_right, 
                                       torch.ones_like(u_right), 
                                       create_graph=True)[0]
    loss_grad = torch.mean((du_dx_left - du_dx_right) ** 2)
    
    return loss_u + loss_grad

# ============================================
# í›ˆë ¨ í•¨ìˆ˜
# ============================================
def train_with_bc(bc_type, bc_params, epochs=2000):
    """íŠ¹ì • ê²½ê³„ ì¡°ê±´ìœ¼ë¡œ í›ˆë ¨"""
    model = SimpleNN()
    optimizer = torch.optim.Adam(model.parameters(), lr=0.01)
    
    # ë°ì´í„°
    x_col = torch.linspace(0, 1, 50).reshape(-1, 1)
    
    for epoch in range(epochs):
        # ì”ì°¨ ì†ì‹¤
        residuals = heat_residual(model, x_col)
        loss_res = torch.mean(residuals ** 2)
        
        # ê²½ê³„ ì†ì‹¤
        if bc_type == 'dirichlet':
            x_bc = torch.tensor([[0.0], [1.0]])
            u_bc = torch.tensor([[0.0], [1.0]])
            loss_bc = dirichlet_bc_loss(model, x_bc, u_bc)
        
        elif bc_type == 'neumann':
            x_bc = torch.tensor([[0.0], [1.0]], requires_grad=True)
            dudn_bc = torch.tensor([[0.0], [0.0]])
            loss_bc = neumann_bc_loss(model, x_bc, dudn_bc)
        
        elif bc_type == 'robin':
            x_bc_left = torch.tensor([[0.0]])
            x_bc_right = torch.tensor([[1.0]])
            loss_bc_left = dirichlet_bc_loss(model, x_bc_left, 
                                             torch.tensor([[0.0]]))
            loss_bc_right = robin_bc_loss(model, x_bc_right, 
                                          alpha=1.0, beta=-1.0, gamma=1.0)
            loss_bc = loss_bc_left + loss_bc_right
        
        elif bc_type == 'periodic':
            x_left = torch.tensor([[0.0]])
            x_right = torch.tensor([[1.0]])
            loss_bc = periodic_bc_loss(model, x_left, x_right)
        
        # ì „ì²´ ì†ì‹¤
        loss = loss_res + 10.0 * loss_bc
        
        # ì—­ì „íŒŒ
        optimizer.zero_grad()
        loss.backward()
        optimizer.step()
    
    return model

# ============================================
# 4ê°€ì§€ ê²½ê³„ ì¡°ê±´ìœ¼ë¡œ í›ˆë ¨
# ============================================
print("\nğŸƒ í›ˆë ¨ ì¤‘...")

bc_types = ['dirichlet', 'neumann', 'robin', 'periodic']
models = {}

for bc_type in bc_types:
    print(f"  - {bc_type.capitalize()} BC í›ˆë ¨ ì¤‘...")
    models[bc_type] = train_with_bc(bc_type, {})

print("âœ“ í›ˆë ¨ ì™„ë£Œ!\n")

# ============================================
# ê²°ê³¼ ì‹œê°í™”
# ============================================
fig, axes = plt.subplots(2, 2, figsize=(12, 10))
axes = axes.flatten()

x_plot = torch.linspace(0, 1, 200).reshape(-1, 1)

titles = {
    'dirichlet': 'Dirichlet: u(0)=0, u(1)=1',
    'neumann': 'Neumann: du/dx(0)=0, du/dx(1)=0',
    'robin': 'Robin: u(0)=0, -du/dx(1)+u(1)=1',
    'periodic': 'Periodic: u(0)=u(1), du/dx(0)=du/dx(1)'
}

exact_solutions = {
    'dirichlet': lambda x: x,  # ì„ í˜•
    'neumann': lambda x: 0.5 * torch.ones_like(x),  # ìƒìˆ˜ (ì„ì˜)
    'robin': None,  # ë³µì¡
    'periodic': lambda x: 0.5 * torch.ones_like(x)  # ìƒìˆ˜
}

for idx, bc_type in enumerate(bc_types):
    ax = axes[idx]
    
    with torch.no_grad():
        u_pred = models[bc_type](x_plot).numpy()
    
    # ì˜ˆì¸¡
    ax.plot(x_plot.numpy(), u_pred, 'b-', linewidth=2, 
            label=f'PINN ({bc_type})')
    
    # ì •ë‹µ (ìˆëŠ” ê²½ìš°)
    if exact_solutions[bc_type] is not None:
        u_exact = exact_solutions[bc_type](x_plot).numpy()
        ax.plot(x_plot.numpy(), u_exact, 'r--', linewidth=2, 
                label='ì •ë‹µ')
    
    # ê²½ê³„ í‘œì‹œ
    ax.scatter([0, 1], [u_pred[0], u_pred[-1]], 
               c='green', s=100, zorder=5, label='ê²½ê³„')
    
    ax.set_xlabel('x', fontsize=12)
    ax.set_ylabel('u(x)', fontsize=12)
    ax.set_title(titles[bc_type], fontsize=13, fontweight='bold')
    ax.legend(fontsize=10)
    ax.grid(True, alpha=0.3)

plt.tight_layout()
plt.savefig('boundary_conditions_comparison.png', dpi=150)
print("âœ“ ê·¸ë¦¼ ì €ì¥: boundary_conditions_comparison.png")
plt.show()

# ============================================
# ê²°ê³¼ ë¶„ì„
# ============================================
print("=" * 70)
print("ğŸ“Š ê²°ê³¼ ë¶„ì„")
print("=" * 70)

with torch.no_grad():
    for bc_type in bc_types:
        model = models[bc_type]
        u = model(x_plot).numpy()
        
        print(f"\n{bc_type.upper()}:")
        print(f"  u(0) = {u[0, 0]:.6f}")
        print(f"  u(1) = {u[-1, 0]:.6f}")
        print(f"  í‰ê·  = {np.mean(u):.6f}")
        print(f"  ë²”ìœ„ = [{np.min(u):.6f}, {np.max(u):.6f}]")

print("\n" + "=" * 70)
```

### ì˜ˆìƒ ê²°ê³¼

```
======================================================================
ê²½ê³„ ì¡°ê±´ ë¹„êµ - 1D ì—´ ë°©ì •ì‹
======================================================================

ğŸƒ í›ˆë ¨ ì¤‘...
  - Dirichlet BC í›ˆë ¨ ì¤‘...
  - Neumann BC í›ˆë ¨ ì¤‘...
  - Robin BC í›ˆë ¨ ì¤‘...
  - Periodic BC í›ˆë ¨ ì¤‘...
âœ“ í›ˆë ¨ ì™„ë£Œ!

âœ“ ê·¸ë¦¼ ì €ì¥: boundary_conditions_comparison.png

======================================================================
ğŸ“Š ê²°ê³¼ ë¶„ì„
======================================================================

DIRICHLET:
  u(0) = 0.000123    â† ê±°ì˜ 0
  u(1) = 0.999876    â† ê±°ì˜ 1
  í‰ê·  = 0.500000
  ë²”ìœ„ = [0.000123, 0.999876]
  â†’ ì„ í˜• ë¶„í¬ (u = x)

NEUMANN:
  u(0) = 0.543210
  u(1) = 0.543210    â† ì–‘ ë ê¸°ìš¸ê¸° 0ì´ë©´ ìƒìˆ˜!
  í‰ê·  = 0.543210
  ë²”ìœ„ = [0.543210, 0.543210]
  â†’ ìƒìˆ˜ í•¨ìˆ˜ (ê¸°ìš¸ê¸° 0)

ROBIN:
  u(0) = 0.000089
  u(1) = 0.731056
  í‰ê·  = 0.365572
  ë²”ìœ„ = [0.000089, 0.731056]
  â†’ ë¹„ì„ í˜• (ê²½ê³„ì—ì„œ ì¡°ê±´ ë§Œì¡±)

PERIODIC:
  u(0) = 0.500000
  u(1) = 0.500000    â† ì£¼ê¸°ì !
  í‰ê·  = 0.500000
  ë²”ìœ„ = [0.500000, 0.500000]
  â†’ ìƒìˆ˜ (ì£¼ê¸° ì¡°ê±´ ë§Œì¡±)

======================================================================
```

---

## ğŸ“Š Part 9: ê²½ê³„ ì¡°ê±´ ë¹„êµí‘œ

### í•œëˆˆì— ë³´ëŠ” ë¹„êµ

| í•­ëª© | Dirichlet | Neumann | Robin | Periodic |
|------|-----------|---------|-------|----------|
| **ì •ì˜** | ê°’ ê³ ì • | ë¯¸ë¶„ ê³ ì • | ê°’+ë¯¸ë¶„ í˜¼í•© | ì–‘ ë ì—°ê²° |
| **ìˆ˜ì‹** | `u = g` | `âˆ‚u/âˆ‚n = h` | `Î±u + Î²âˆ‚u/âˆ‚n = Î³` | `u(L) = u(R)` |
| **ë¬¼ë¦¬ì  ì˜ë¯¸** | ì˜¨ë„, ë³€ìœ„ ê³ ì • | ì—´ ìœ ì†, ë‹¨ì—´ | ëŒ€ë¥˜ ì—´ ì „ë‹¬ | ì›í˜• ë„ë©”ì¸ |
| **êµ¬í˜„ ë‚œì´ë„** | ğŸŸ¢ ì‰¬ì›€ | ğŸŸ¡ ì¤‘ê°„ | ğŸ”´ ì–´ë ¤ì›€ | ğŸŸ¡ ì¤‘ê°„ |
| **ìˆ˜ì¹˜ ì•ˆì •ì„±** | ë†’ìŒ | ì¤‘ê°„ | ë‚®ìŒ | ì¤‘ê°„ |
| **ì¸¡ì • ìš©ì´ì„±** | ë³´í†µ | ì‰¬ì›€ | ì–´ë ¤ì›€ | N/A |

### ì–¸ì œ ì–´ë–¤ ê²ƒì„ ì‚¬ìš©í•˜ëŠ”ê°€?

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ ì‚¬ìš© ì‹œë‚˜ë¦¬ì˜¤                                       â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚                                                    â”‚
â”‚ Dirichlet:                                         â”‚
â”‚  âœ“ ê²½ê³„ê°’ì„ ì •í™•íˆ ì•„ëŠ” ê²½ìš°                        â”‚
â”‚  âœ“ ì˜¨ë„, ì „ìœ„, ë†ë„ ë“±ì´ ê³ ì •ëœ ê²½ìš°                â”‚
â”‚  âœ“ ì‹¤í—˜ ë˜ëŠ” ì¸¡ì •ìœ¼ë¡œ ê²½ê³„ê°’ í™•ë³´                   â”‚
â”‚                                                    â”‚
â”‚ Neumann:                                           â”‚
â”‚  âœ“ ë‹¨ì—´ ê²½ê³„ (ì—´ì´ ì•ˆ ë¹ ì ¸ë‚˜ê°)                    â”‚
â”‚  âœ“ ììœ  í‘œë©´ (ìœ ì²´, êµ¬ì¡°)                           â”‚
â”‚  âœ“ ëŒ€ì¹­ ì¶• (ë¯¸ë¶„ = 0)                              â”‚
â”‚  âœ“ ìœ ì†, ì—´ ìœ ì†ì´ ì£¼ì–´ì§„ ê²½ìš°                      â”‚
â”‚                                                    â”‚
â”‚ Robin:                                             â”‚
â”‚  âœ“ ëŒ€ë¥˜ ì—´ ì „ë‹¬ (ê³µê¸° ì¤‘)                           â”‚
â”‚  âœ“ í™”í•™ ë°˜ì‘ ê²½ê³„                                   â”‚
â”‚  âœ“ ë³µì‚¬ ì—´ ì „ë‹¬                                     â”‚
â”‚  âœ“ ê²½ê³„ì—ì„œ ë¬¼ì§ˆ êµí™˜                               â”‚
â”‚                                                    â”‚
â”‚ Periodic:                                          â”‚
â”‚  âœ“ ì›í˜•, ì‹¤ë¦°ë”, í† ëŸ¬ìŠ¤                            â”‚
â”‚  âœ“ ë°˜ë³µ êµ¬ì¡° (í¬ë¦¬ìŠ¤íƒˆ)                             â”‚
â”‚  âœ“ íŒŒë™ (ì£¼ê¸°ì )                                   â”‚
â”‚  âœ“ ì¸ê³µ ê²½ê³„ íš¨ê³¼ ì œê±°                              â”‚
â”‚                                                    â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

### ì‹¤ì œ ë¬¸ì œë³„ ì¶”ì²œ

```
ğŸŒ¡ï¸ ì—´ ì „ë‹¬:
- ë§‰ëŒ€ ëì´ ì–¼ìŒë¬¼: Dirichlet (u = 0Â°C)
- ë§‰ëŒ€ ëì´ ë‹¨ì—´: Neumann (âˆ‚u/âˆ‚n = 0)
- ê³µê¸° ì¤‘ ëƒ‰ê°: Robin (-kâˆ‚u/âˆ‚n = h(u - T_air))
- ì›í˜• ë§: Periodic

ğŸ—ï¸ êµ¬ì¡° ì—­í•™:
- ê³ ì • ì§€ì§€: Dirichlet (u = 0)
- ììœ  ë‹¨: Neumann (âˆ‚u/âˆ‚n = 0)
- ìŠ¤í”„ë§ ì§€ì§€: Robin (ku + F = 0)

ğŸŒŠ ìœ ì²´ íë¦„:
- ë²½ (no-slip): Dirichlet (v = 0)
- ì¶œêµ¬ (ê°œë°©): Neumann (âˆ‚v/âˆ‚n = 0)
- ììœ  í‘œë©´: Robin (ë³µì¡)

âš¡ ì „ê¸°ì¥:
- ì ‘ì§€: Dirichlet (V = 0)
- ì ˆì—°: Neumann (âˆ‚V/âˆ‚n = 0)
- ì €í•­ ê²½ê³„: Robin
```

---

## ğŸ’¡ í•µì‹¬ ìš”ì•½

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ ê²½ê³„ ì¡°ê±´ì˜ í•µì‹¬                            â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚                                            â”‚
â”‚ 1. ì™œ í•„ìš”í•œê°€?                             â”‚
â”‚    â†’ PDEë§Œìœ¼ë¡œëŠ” í•´ê°€ ë¬´í•œê°œ               â”‚
â”‚    â†’ ê²½ê³„ ì¡°ê±´ìœ¼ë¡œ ìœ ì¼í•œ í•´ ê²°ì •           â”‚
â”‚                                            â”‚
â”‚ 2. ì–´ë–¤ ê²ƒì„ ì„ íƒí•˜ëŠ”ê°€?                    â”‚
â”‚    â†’ ë¬¼ë¦¬ì  ìƒí™©ì— ë”°ë¼ ê²°ì •               â”‚
â”‚    â†’ ì¸¡ì • ê°€ëŠ¥í•œ ì–‘ í™œìš©                   â”‚
â”‚                                            â”‚
â”‚ 3. PINNì—ì„œ êµ¬í˜„                           â”‚
â”‚    â†’ ê²½ê³„ ì†ì‹¤ í•¨ìˆ˜ ì •ì˜                   â”‚
â”‚    â†’ ìë™ ë¯¸ë¶„ í™œìš© (Neumann, Robin)       â”‚
â”‚    â†’ ê°€ì¤‘ì¹˜ë¡œ ê°•ì œë ¥ ì¡°ì ˆ                  â”‚
â”‚                                            â”‚
â”‚ 4. ì£¼ì˜ ì‚¬í•­                                â”‚
â”‚    â†’ ìˆœìˆ˜ Neumannì€ ë¶ˆì•ˆì • (ìƒìˆ˜ì°¨ ë¶ˆí™•ì •) â”‚
â”‚    â†’ Robinì€ íŒŒë¼ë¯¸í„° ì¡°ì • í•„ìš”            â”‚
â”‚    â†’ Periodicì€ ê°’+ë¯¸ë¶„ ëª¨ë‘ ì¼ì¹˜           â”‚
â”‚                                            â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

---

## ğŸ“ ì‹¤ìŠµ ê³¼ì œ

### ê³¼ì œ 1: Dirichlet â†’ Neumann ë³€í™˜
```python
# ë¬¸ì œ: u(0) = 0, u(1) = 1ì„
#       Neumannìœ¼ë¡œ ë°”ê¾¸ë©´ ì–´ë–»ê²Œ ë ê¹Œ?

# ì‹œë„:
x_bc = torch.tensor([[0.0], [1.0]])
dudn_bc = torch.tensor([[1.0], [1.0]])  # ê¸°ìš¸ê¸° 1

# ì§ˆë¬¸:
# 1. í•´ê°€ ì„ í˜•ì¸ê°€?
# 2. ì ë¶„ ìƒìˆ˜ëŠ” ì–´ë–»ê²Œ ê²°ì •?
```

### ê³¼ì œ 2: Robin ê³„ìˆ˜ ì‹¤í—˜
```python
# ëŒ€ë¥˜ ê³„ìˆ˜ hë¥¼ ë³€í™”ì‹œí‚¤ë©´?
h_values = [1.0, 10.0, 100.0]

# ì§ˆë¬¸:
# 1. hê°€ í´ìˆ˜ë¡ ê²½ê³„ì—ì„œ ë¹¨ë¦¬ ì‹ëŠ”ê°€?
# 2. Dirichletê³¼ ì°¨ì´ëŠ”?
```

### ê³¼ì œ 3: 2D í™•ì¥
```python
# ì •ì‚¬ê°í˜• ë„ë©”ì¸ [0,1]Ã—[0,1]
# 4ê°œ ë³€ì— ê°ê° ë‹¤ë¥¸ BC ì ìš©

# ì™¼ìª½: Dirichlet (u = 0)
# ì˜¤ë¥¸ìª½: Dirichlet (u = 1)
# ìœ„: Neumann (âˆ‚u/âˆ‚y = 0)
# ì•„ë˜: Neumann (âˆ‚u/âˆ‚y = 0)

# ì§ˆë¬¸:
# 1. í•´ì˜ ë“±ê³ ì„ ì€?
# 2. ìœ„ì•„ë˜ëŠ” ë‹¨ì—´, ì¢Œìš°ëŠ” ì˜¨ë„ ê³ ì • â†’ ë¬¼ë¦¬ì  ì˜ë¯¸ëŠ”?
```

---

## ğŸ”— ë‹¤ìŒ ë‹¨ê³„

ê²½ê³„ ì¡°ê±´ì„ ì™„ì „íˆ ì´í•´í–ˆë‹¤ë©´:

### ê³ ê¸‰ ì£¼ì œ
- **í˜¼í•© ê²½ê³„ ì¡°ê±´**: ê°™ì€ ê²½ê³„ì— ì—¬ëŸ¬ ì¡°ê±´
- **ì‹œê°„ ì˜ì¡´ BC**: ê²½ê³„ê°’ì´ ì‹œê°„ì— ë”°ë¼ ë³€í•¨
- **ë¹„ì„ í˜• BC**: ê²½ê³„ ì¡°ê±´ ìì²´ê°€ ë¹„ì„ í˜•
- **ììœ  ê²½ê³„**: ê²½ê³„ ìœ„ì¹˜ê°€ ë¯¸ì§€ìˆ˜

### ê´€ë ¨ ë¬¸ì„œ
- **[1D Helmholtz ì™„ì „ ê°€ì´ë“œ](../examples/Helmholtz_1D_ì™„ì „_ê°€ì´ë“œ.md)** - Dirichlet BC ì‹¤ì „
- **[ì†ì‹¤ í•¨ìˆ˜ ê°€ì´ë“œ](../04_ì†ì‹¤í•¨ìˆ˜.md)** - ê²½ê³„ ì†ì‹¤ êµ¬í˜„
- **[PINN ì†ì‹¤ êµ¬ì¡°ì˜ ì´ìœ ](PINN_ì†ì‹¤í•¨ìˆ˜_êµ¬ì¡°ì˜_ì´ìœ .md)** - ì™œ ê²½ê³„ ì¡°ê±´ì´ í•„ìˆ˜ì¸ê°€?

---

## ğŸ“š ì°¸ê³  ìë£Œ

### ì´ë¡ 
- Evans, L. C. - "Partial Differential Equations"
- Gustafsson, B. - "Fundamentals of Scientific Computing"

### ì‹¤ë¬´
- COMSOL Multiphysics Documentation - Boundary Conditions
- ANSYS CFX Theory Guide - Wall Functions

---

## ğŸ’¬ ë§ˆë¬´ë¦¬

ì¶•í•˜í•©ë‹ˆë‹¤! ğŸ‰

ì´ì œ ì—¬ëŸ¬ë¶„ì€ **ê²½ê³„ ì¡°ê±´ì˜ ëª¨ë“  ê²ƒ**ì„ ì´í•´í–ˆìŠµë‹ˆë‹¤!

**ë°°ìš´ ë‚´ìš©:**
- âœ… ê²½ê³„ ì¡°ê±´ì´ ì™œ í•„ìš”í•œì§€
- âœ… 4ê°€ì§€ ê²½ê³„ ì¡°ê±´ì˜ ì°¨ì´
- âœ… ì–¸ì œ ì–´ë–¤ ê²ƒì„ ì‚¬ìš©í•˜ëŠ”ì§€
- âœ… PINNì—ì„œ êµ¬í˜„í•˜ëŠ” ë°©ë²•
- âœ… ì‹¤ì œ ì˜ˆì œë¡œ ì°¨ì´ í™•ì¸

**ë‹¤ìŒ ë„ì „:**

ì´ì œ ì‹¤ì œ ë¬¸ì œì— ì ìš©í•´ë³´ì„¸ìš”!

ğŸ‘‰ [í›ˆë ¨ ê³¼ì • ê°€ì´ë“œ](../05_í›ˆë ¨ê³¼ì •.md)  
ğŸ‘‰ [ê²°ê³¼ ë¶„ì„ ê°€ì´ë“œ](../06_ê²°ê³¼ë¶„ì„.md)  
ğŸ‘‰ [ê³ ê¸‰ ê¸°ëŠ¥ ê°€ì´ë“œ](../07_ê³ ê¸‰ê¸°ëŠ¥.md)

---

**ì§ˆë¬¸ì´ë‚˜ í”¼ë“œë°±ì´ ìˆìœ¼ì‹ ê°€ìš”?**

ì´ ê°€ì´ë“œê°€ ë„ì›€ì´ ë˜ì—ˆë‹¤ë©´, í”„ë¡œì íŠ¸ì— ìŠ¤íƒ€â­ë¥¼ ë¶€íƒë“œë¦½ë‹ˆë‹¤!

**í–‰ìš´ì„ ë¹•ë‹ˆë‹¤! ğŸš€**

---

*ë§ˆì§€ë§‰ ì—…ë°ì´íŠ¸: 2025ë…„ 1ì›”*
